<html>

	<head>
		<title>sndfjklnsfkld</title>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js'></script>
		<script src='node_modules\three\examples\js\loaders\GLTFLoader.js'></script>
		<script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
		<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
	</head>
	
	<style>
		#container{
			border: 1px solid #000;
		}
	</style>
	
	<body>
		<div id='container'>
		</div>
	</body>

	<script>
	
		const WIDTH = 1400;
		const HEIGHT = 600;
		const VIEW_ANGLE = 100;
		const ASPECT = WIDTH / HEIGHT;
		const NEAR = 1;
		const FAR = 1000;
		const LEFT = WIDTH / -10;
		const RIGHT = WIDTH / 10;
		const TOP = HEIGHT / 10;
		const BOTTOM = HEIGHT / -10;
		
		const container = document.querySelector('#container');
		const renderer = new THREE.WebGLRenderer();
		const camera = new THREE.OrthographicCamera(LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);	
		const scene = new THREE.Scene();
	
		let loader = new THREE.GLTFLoader();
		let obj = null;
		let area = null;
		let boundingSphereRadius = null;
		let playerUnits = {};
		
		let currSelectedObj = null;
		let showArea = false;
		let spotLight = new THREE.SpotLight( 0xffffff );
		spotLight.position.set( 0, 0, 1 );
		spotLight.castShadow = true;
		spotLight.shadow.mapSize.width = 3000;
		spotLight.shadow.mapSize.height = 500;
		spotLight.shadow.camera.near = 10;
		spotLight.shadow.camera.far = 1000;
		spotLight.shadow.camera.fov = 30;
		scene.add(spotLight);
		
		let loadedModels = [];
			
		let raycaster = new THREE.Raycaster();
		let mouse = new THREE.Vector2(-1, -1);
	
		function getModel(modelFilePath, side, name){
			return new Promise((resolve, reject) => {
				loader.load(
					modelFilePath,
					function(gltf){
						gltf.scene.traverse((child) => {
							if(child.type === "Mesh"){
							
								let material = child.material;
								let geometry = child.geometry;
								let obj = new THREE.Mesh(geometry, material);
								
								obj.scale.x = child.scale.x * 20;
								obj.scale.y = child.scale.y * 20;
								obj.scale.z = child.scale.z * 20;
								obj.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI / 2); // note this on object's local axis! so when you rotate, the axes change (i.e. x becomes z)
								obj.rotateOnAxis(new THREE.Vector3(0,0,1), Math.PI / 2);
							
								obj.side = side; // player or enemy mesh?
								obj.name = name;
								resolve(obj);
							}
						});
					},
					// called while loading is progressing
					function(xhr){
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// called when loading has errors
					function(error){
						console.log( 'An error happened' );
						console.log(error);
					}
				);
			});
		}
		
		// https://codepen.io/Xanmia/pen/DoljI
		var movementSpeed = 10;
		var totalObjects = 1000;
		var objectSize = 10;
		var sizeRandomness = 4000;
		var colors = [0xFF0FFF, 0xCCFF00, 0xFF000F, 0x996600, 0xFFFFFF];
		var dirs = [];
		var parts = [];

		function explodeAnimation(x,y){
		  var geometry = new THREE.Geometry();
		  
		  for (i = 0; i < totalObjects; i++) 
		  { 
		  				let randX = Math.floor(Math.random() * (30 - (-30) + 1) + (-30));
				let randY = Math.floor(Math.random() * (60 - (-60) + 1) + (-60));
			var vertex = new THREE.Vector3();
			vertex.x = randX;//x;
			vertex.y = randY; //y;
			vertex.z = -450;
			console.log(vertex);
		  
			geometry.vertices.push( vertex );
			dirs.push({x:(Math.random() * movementSpeed)-(movementSpeed/2),y:(Math.random() * movementSpeed)-(movementSpeed/2),z:(Math.random() * movementSpeed)-(movementSpeed/2)});
		  }
		  var material = new THREE.PointsMaterial( { size: objectSize,  color: colors[Math.round(Math.random() * colors.length)] });
		  var particles = new THREE.Points( geometry, material );
		  
		  this.object = particles;
		  this.status = true;
		  
		  		  				let randX = Math.floor(Math.random() * (30 - (-30) + 1) + (-30));
				let randY = Math.floor(Math.random() * (60 - (-60) + 1) + (-60));
		  this.xDir = randX;//(Math.random() * movementSpeed)-(movementSpeed/2);
		  this.yDir = randY;//(Math.random() * movementSpeed)-(movementSpeed/2);
		  this.zDir = -450; //(Math.random() * movementSpeed)-(movementSpeed/2);
		  
		  scene.add(this.object); 
		  
		  this.update = function(){
			if (this.status === true){
			  var pCount = totalObjects;
			  while(pCount--) {
				var particle = this.object.geometry.vertices[pCount];
				particle.y += dirs[pCount].y;
				particle.x += dirs[pCount].x;
				particle.z += dirs[pCount].z;
			  }
			  this.object.geometry.verticesNeedUpdate = true;
			}
		  }
		}
		
		function attackUnit(target){
			// particle explosion 
			parts.push(new explodeAnimation((Math.random() * sizeRandomness)-(sizeRandomness/2), (Math.random() * sizeRandomness)-(sizeRandomness/2)));
			$('#container').effect("bounce");
		}
		
		function showUnitArea(obj, circle){
			circle.position.set(obj.position.x, obj.position.y, -450);
			scene.add(circle);
		}
		
		function hideUnitArea(circle){
			scene.remove(circle);
		}
		
		function convert2dCoordsTo3d(evt){
			let target = renderer.domElement;
			let box = target.getBoundingClientRect();

			let x1 = evt.clientX - box.left;
			let y1 = evt.clientY - box.top;
			let posX = x1 * target.width  / target.clientWidth;
			let posY = y1 * target.height / target.clientHeight;

			let x = posX / parseInt(target.width) * 2 - 1;
			let y = posY / parseInt(target.height) * -2 + 1;
			let v = new THREE.Vector3(x, y, -450).unproject( camera ); // understand what unproject does, cause it gives a ridiculous z value
			v.z = -450;
			return v;
		}
		

		loadedModels.push(getModel('../assets/battleship-edit.glb', 'player', 'p1'));
		loadedModels.push(getModel('../assets/battleship2.glb', 'enemy', 'e1'));
		
		Promise.all(loadedModels).then((objects) => {
			objects.forEach((mesh) => {
				
				let randX = Math.floor(Math.random() * (30 - (-30) + 1) + (-30));
				let randY = Math.floor(Math.random() * (60 - (-60) + 1) + (-60));
				mesh.position.set(randX, randY, -450);

				scene.add(mesh);
				mesh.geometry.computeBoundingSphere();
				boundingSphereRadius = mesh.geometry.boundingSphere.radius;
				//console.log(boundingSphereRadius);
				
				let geometry = new THREE.CircleGeometry( 17, 32 ); //new THREE.CircleGeometry( boundingSphereRadius, 32 );
				let material;
				if(mesh.side === "player"){
					material = new THREE.MeshBasicMaterial({color: 0xffff00});
				}else if(mesh.side === "enemy"){
					material = new THREE.MeshBasicMaterial({ color: 0x0000ff } ); // default is 0xffffff, fyi. you want transparent
				}
				// make one circle for attack range, and one for movement range
				let circle = new THREE.Mesh( geometry, material );
				circle.name = "selectArea";
			
				mesh.selectArea = circle;
				if(mesh.side === "enemy"){
					circle.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
					scene.add(circle);
					circle.side = "enemyArea";
				}else{
					circle.side = "playerArea";
				}
				
				// try this instead https://threejs.org/docs/#api/en/core/Raycaster
				// for knowing what unit the mouse is over 
				//playerUnits["unit1"] = {'x': obj.position.x, 'y': obj.position.y}; // every time this unit moves it needs to be updated
				
				renderer.render(scene, camera);
				
				//window.addEventListener( 'mousemove', onMouseMove, false );
				//window.requestAnimationFrame(render);
			})
		});
		

		scene.background = new THREE.Color( 0xffffff );	
		scene.add(camera);
		renderer.setSize(WIDTH, HEIGHT);	
		container.appendChild(renderer.domElement);
		
		function raycast(){
			// update the picking ray with the camera and mouse position
			raycaster.setFromCamera( mouse, camera );
			// calculate objects intersecting the picking ray
			var intersects = raycaster.intersectObjects( scene.children );

			// check if multiple hits! i.e. if player unit's area and enemy area overlap
			// see if current unit's selectArea and an enemy's selectArea intersect
			// if so, can't move 
			intersectCheck = {};
			intersects.forEach((obj) => {
				if(obj.object.name === "selectArea" && (obj.object.side === "enemyArea" || obj.object.side === "playerArea")){
					intersectCheck[obj.object.side] = 1;
				}
			});
			if(intersectCheck["enemyArea"] && intersectCheck["playerArea"]){
				console.log("can't move - this point is an intersection with an enemy. try attacking?");
				return false;
			}

			let colors = [0xff0000, 0x00ff00, 0x0000ff];
			//console.log(intersects);
			for(var i = 0; i < intersects.length; i++) {
				//console.log("hit!");
				if(intersects[i].object.side === "player"){
					//console.log("player hit");
					intersects[i].object.material.color.set( colors[i % colors.length] );
					return intersects[i].object;
				}else if(intersects[i].object.name === "selectArea"){
					console.log("clicked on selectarea");
					return intersects[i].object;
				}else if(intersects[i].object.side === "enemy" && currSelectedObj){
					// need to make sure target is within range also!!
					console.log("attacking enemy");
					return intersects[i].object;
				}
			}
			
			
			return false;
		}
		
		function inRange(v1, v2, limit){
			return (v1.x <= v2.x + limit && v1.x >= v2.x - limit && v1.y <= v2.y + limit && v1.y >= v2.y - limit);
		}
		
		function move(object, targetPos, directionVec, setIntervalName){
			// stop movement if reach target		
			// remember that in 3d space, downward movement means increasing negative numbers (unlike in 2d where going down means increasing positive value)
			if(inRange(object.position, targetPos, 0.1)){
				//console.log("reached destination: x: " + object.position.x + ", y: " + object.position.y);
				clearInterval(setIntervalName);
			}else{
				object.position.addScaledVector(directionVec, 0.2);
			}
			//renderer.render(scene, camera);
		}
		
		function rotate(object, angle, targetVec, setIntervalName){
			let limit = 0.02;
			let angleBetween = getAngleBetween(object, targetVec);
			if(angleBetween >= -limit && angleBetween <= limit){
				console.log("finished rotating");
				clearInterval(setIntervalName);
			}else{
				object.rotateOnAxis(new THREE.Vector3(0,1,0), angle);
			}
			//renderer.render(scene, camera);
		}
		
		function getAngleBetween(obj, vec){
			let matrix = new THREE.Matrix4();
			matrix.extractRotation( obj.matrix );
			let direction = new THREE.Vector3( 0, 0, 1 );
			direction.applyMatrix4(matrix);

			let currDirectionVector = direction; 
			let angleBetween = currDirectionVector.angleTo(vec);
			return angleBetween;
		}
						
		renderer.domElement.addEventListener('click', (e) => {
			let v = convert2dCoordsTo3d(e);
			//console.log(v);
			
			mouse.x = (( e.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width) * 2 - 1;
			mouse.y = - (( e.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height) * 2 + 1;

			let res = raycast();
			//console.log(res);
			if(res){
				if(showArea && res.side === "player"){
					console.log("hide select area");
					hideUnitArea(res.selectArea);
					showArea = false;
					currSelectedObj = null;
				}else if(showArea && res.name === "selectArea" && currSelectedObj.side === "player"){
					console.log("moving");
					// move unit?
					let obj = currSelectedObj;
					// point unit in direction and move if possible
					// step 1: get 3d point clicked on 
					// step 2: get vector using point clicked on and unit's curr coords 
					// step 3: given curr unit's curr direction vector, find angle between 
					//			vector and the vector obtained in step 2.
					// step 4: rotate curr unit vector x degrees from step 3.
					let vec = new THREE.Vector3(v.x - obj.position.x, v.y - obj.position.y, v.z - obj.position.z);
					
					// get curr unit direction vector 
					// https://github.com/mrdoob/three.js/issues/1606
					let angleBetween = getAngleBetween(obj, vec);
					
					// figure out if the angle should be added (clockwise) or subtracted (rotate counterclckwise)
					// https://stackoverflow.com/questions/16613616/work-out-whether-to-turn-clockwise-or-anticlockwise-from-two-angles
					let matrix = new THREE.Matrix4();
					matrix.extractRotation(obj.matrix);
					let direction = new THREE.Vector3( 0, 0, 1 );
					direction.applyMatrix4(matrix);
					let currDirectionVector = direction; 
			
					let crossProductLength = currDirectionVector.cross(vec);
					if(crossProductLength.z > 0){
						// clockwise
						let rotateFunc = setInterval(
							function(){
								rotate(obj, angleBetween / 40, vec, rotateFunc);
							}, 35
						);
					}else{
						// counterclockwise
						let rotateFunc = setInterval(
							function(){
								rotate(obj, -angleBetween / 40, vec, rotateFunc);
							}, 35
						);
					}
					
					// move to point clicked 
					//console.log("curr position: x: " + obj.position.x + ", y: " + obj.position.y);
					vec.normalize();
					//console.log("destination position: x: " + v.x + ", y: " + v.y);
					let moveFunc = setInterval(
							function(){
								move(obj, v, vec, moveFunc);
							}, 30
						);
					
					hideUnitArea(res);
					showArea = false;
				}else if(res.side === "player"){
					currSelectedObj = res;
					showUnitArea(res, res.selectArea);
					showArea = true;
				}else if(res.side === "enemy"){
					attackUnit();
				}
			}
			
			//renderer.render(scene, camera);
		});
		
		
		function render() {
			requestAnimationFrame( render );
			 
			var pCount = parts.length;
			  while(pCount--) {
				parts[pCount].update();
			  }
			renderer.render(scene, camera);
		}
		render();
		


	</script>

</html>