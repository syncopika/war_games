<html>

	<head>
		<title>sndfjklnsfkld</title>
		
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js'></script>
		<script src='node_modules\three\examples\js\loaders\GLTFLoader.js'></script>
		<script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
		<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
		<script src="nearestneighbor.js"></script>
	</head>
	
	<style>
		canvas{
			border: 1px solid #000;
		}
	</style>
	
	<body>
		<div id='container'>
		</div>
		<button onclick='enemyMove()'> end turn </button>
	</body>

	<script>
	//import { Water } from '/node_modules/three/examples/jsm/objects/Water.js';
	// https://forums.ogre3d.org/viewtopic.php?t=47645
	
	
	// https://stemkoski.github.io/Three.js/Shader-Animate.html
	var waterShader = {
	
		vertexShader: [
			'varying vec2 vUv;',
			'void main(){',
			'   vUv = uv;',
			'   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}'
		].join('\n'),
		
		fragmentShader: [
			'uniform sampler2D baseTexture;',
			'uniform float baseSpeed;',
			'uniform sampler2D noiseTexture;',
			'uniform float noiseScale;',
			'uniform float alpha;',
			'uniform float time;',
			'varying vec2 vUv;',
			'void main() {',
			'	vec2 uvTimeShift = vUv + vec2( -0.7, 1.2 ) * time * baseSpeed;'	,
			'	vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );',
			'	vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );',
			'	vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift );',
			'	baseColor.a = alpha;',
			'	gl_FragColor = baseColor;}',
		].join('\n')
	}

		const WIDTH = 1400;
		const HEIGHT = 600;
		const VIEW_ANGLE = 100;
		const ASPECT = WIDTH / HEIGHT;
		const NEAR = 1;
		const FAR = 1000;
		const LEFT = WIDTH / -10;
		const RIGHT = WIDTH / 10;
		const TOP = HEIGHT / 10;
		const BOTTOM = HEIGHT / -10;
		
		const container = document.querySelector('#container');
		const renderer = new THREE.WebGLRenderer();
		renderer.shadowMap.enabled = true;
		const camera = new THREE.OrthographicCamera(LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);
		const scene = new THREE.Scene();
	
		let loader = new THREE.GLTFLoader();
		let obj = null;
		let area = null;
		let boundingSphereRadius = null;
		let playerUnits = [];
		let enemyUnits = [];
		
		let currSelectedObj = null;
		let showArea = false;
		let spotLight = new THREE.PointLight( 0xffffff, 1, -1 ); //new THREE.SpotLight( 0xffffff );
		spotLight.position.set( 0, 0, -200 );
	
		spotLight.castShadow = true;
		spotLight.shadow.mapSize.width = 512;
		spotLight.shadow.mapSize.height = 512;
		spotLight.shadow.camera.near = 10;
		spotLight.shadow.camera.far = 1000;
		spotLight.shadow.camera.fov = 30;
	
		scene.add(spotLight);
		
		let loadedModels = [];
			
		let raycaster = new THREE.Raycaster();
		let mouse = new THREE.Vector2(-1, -1);
	
		function getModel(modelFilePath, side, name){
			return new Promise((resolve, reject) => {
				loader.load(
					modelFilePath,
					function(gltf){
						gltf.scene.traverse((child) => {
							if(child.type === "Mesh"){
							
								let material = child.material;
								let geometry = child.geometry;
								let obj = new THREE.Mesh(geometry, material);
								
								obj.scale.x = child.scale.x * 20;
								obj.scale.y = child.scale.y * 20;
								obj.scale.z = child.scale.z * 20;
								obj.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI / 2); // note this on object's local axis! so when you rotate, the axes change (i.e. x becomes z)
								obj.rotateOnAxis(new THREE.Vector3(0,0,1), Math.PI / 2);
							
								obj.side = side; // player or enemy mesh?
								obj.name = name;
								resolve(obj);
							}
						});
					},
					// called while loading is progressing
					function(xhr){
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// called when loading has errors
					function(error){
						console.log( 'An error happened' );
						console.log(error);
					}
				);
			});
		}
		
	
		let wakeParts = [];
		let totalWakeObjects = 1;
		function wakeAnimation(x, y, obj, targetPos){
			let geometry = new THREE.Geometry();
			let wakeDirs = [];
			//let distance = 0.5;
			
			let forward = new THREE.Vector3(targetPos.x - obj.position.x, targetPos.y - obj.position.y, -450); 
			
			// https://github.com/mrdoob/three.js/issues/1606
			let forward2 = new THREE.Vector3(0,0,1).applyQuaternion(obj.quaternion);
			
			// negative x = moving right 
			// negative y = moving up 
			// need to add x and y in the correct direction based on forward
			let colors = ['0xffffff']; //'0xefeff9', '0xffffff', '0xe0e2f7', '0xe4e5f1', '0xf1f2fb'
			let color = colors[Math.floor(Math.random() * (colors.length))];

			for(let i = 0; i < totalWakeObjects; i++){ 
				// a wake will form a triangular shape 
				// like this: / \ 
				// so we apply a vertex for the left and right side of the wake. 
				// given the current vector of the object the wake belongs to, we can 
				// form the triangular shape by starting at the stern of the ship (rear - maybe should be the bow)
				// at the stern, the left and right vertices will be closest to the vector horizontally
				// then they gradually increase in distance (x-axis) going further from the stern
				
				// how about this: position the particles at an angle from the current forward vector.
				// so the left particles are something like 30 degrees from the forward vector's REVERSE,
				// and the right particles are -30 from the forward's REVERSE vector.
				/*
				let reverseVec = new THREE.Vector3(forward.x*-1, forward.y*-1, -450);
				let leftVector = getVectorAtAngleFrom(reverseVec, 25); // depending on the object's angle, this left vec might be the right vec
				let rightVector = getVectorAtAngleFrom(reverseVec, -25);
				
				let leftVertex = new THREE.Vector3(obj.position.x, obj.position.y, -450);
				let rightVertex = new THREE.Vector3(obj.position.x, obj.position.y, -450);
				
				forward.multiplyScalar(.7);
				leftVertex.add(leftVector).add(forward);
				rightVertex.add(rightVector).add(forward);
				
				leftVertex.z = -450;
				rightVertex.z = -450;
				
				
				//distance = 0;

				geometry.vertices.push(leftVertex);
				wakeDirs.push({x: leftVertex.x, y: leftVertex.y});

				geometry.vertices.push(rightVertex);
				wakeDirs.push({x: rightVertex.x, y: rightVertex.y});
				*/
				
				//////////////////////////////////////////////////////
				let reverseVec2 = new THREE.Vector3(forward2.x*-1, forward2.y*-1, forward2.z);
				let leftVector2 = getVectorAtAngleFrom(reverseVec2, 20); 
				let rightVector2 = getVectorAtAngleFrom(reverseVec2, -20);
				leftVector2.multiplyScalar(5);
				rightVector2.multiplyScalar(5);
				
				let leftVertex2 = new THREE.Vector3(obj.position.x, obj.position.y, -450);
				let rightVertex2 = new THREE.Vector3(obj.position.x, obj.position.y, -450);
				
				leftVertex2.add(leftVector2);
				rightVertex2.add(rightVector2);
				
				geometry.vertices.push(leftVertex2);
				wakeDirs.push({x: leftVertex2.x, y: leftVertex2.y});

				geometry.vertices.push(rightVertex2);
				wakeDirs.push({x: rightVertex2.x, y: rightVertex2.y});
				
			  }
			  var material = new THREE.PointsMaterial( { size: 7, color: parseInt(color, 16)});
			  var particles = new THREE.Points( geometry, material );
			  this.object = particles;
			  this.status = true;
			  
			  scene.add(this.object); 
			  this.update = function(){
				if (this.status === true){
				  let pCount = this.object.geometry.vertices.length;
				  while(pCount--){
					var particle = this.object.geometry.vertices[pCount];
					particle.x = wakeDirs[pCount].x;
					particle.y = wakeDirs[pCount].y;
				  }
				  this.object.geometry.verticesNeedUpdate = true;
				}else{
					// remove vertices
					console.log("removing particles");
					scene.remove(this.object);
				}
			}
		}
		
		
		// https://codepen.io/Xanmia/pen/DoljI
		let movementSpeed = 20;
		let totalObjects = 50;
		let objectSize = 10;
		let sizeRandomness = 4000;
		let colors = [0xff0000];//, 0xCCFF00, 0xFF000F, 0x996600, 0xFFFFFF];
		let dirs = [];
		let parts = [];

		function explodeAnimation(x, y, target){
		  var geometry = new THREE.Geometry();
		  
		  for (let i = 0; i < totalObjects; i++){ 
			let vertex = new THREE.Vector3();
			vertex.x = target.position.x;
			vertex.y = target.position.y;
			vertex.z = -450;
	  
			geometry.vertices.push( vertex );
			dirs.push({x:(Math.random() * movementSpeed)-(movementSpeed/2),y:(Math.random() * movementSpeed)-(movementSpeed/2),z:(Math.random() * movementSpeed)-(movementSpeed/2)});
		  }
		  var material = new THREE.PointsMaterial( { size: objectSize, color: colors[Math.round(Math.random() * colors.length)] });
		  var particles = new THREE.Points( geometry, material );
		  
		  this.object = particles;
		  this.status = true;
		  
		  let randX = Math.floor(Math.random() * (30 - (-30) + 1) + (-30));
		  let randY = Math.floor(Math.random() * (60 - (-60) + 1) + (-60));
		  this.xDir = randX;//(Math.random() * movementSpeed)-(movementSpeed/2);
		  this.yDir = randY;//(Math.random() * movementSpeed)-(movementSpeed/2);
		  this.zDir = -450; //(Math.random() * movementSpeed)-(movementSpeed/2);
		  
		  scene.add(this.object); 
		  
		  this.update = function(){
			if (this.status === true){
			  var pCount = totalObjects;
			  while(pCount--) {
				var particle = this.object.geometry.vertices[pCount];
				particle.y += dirs[pCount].y;
				particle.x += dirs[pCount].x;
				particle.z += dirs[pCount].z;
			  }
			  this.object.geometry.verticesNeedUpdate = true;
			}
		  }
		}
		
		function attackUnit(target){
			// particle explosion 
			parts.push(new explodeAnimation((Math.random() * sizeRandomness)-(sizeRandomness/2), (Math.random() * sizeRandomness)-(sizeRandomness/2), target));
			$('#container').effect("bounce");
		}
		
		function showUnitArea(obj, circle){
			circle.position.set(obj.position.x, obj.position.y, -450);
			scene.add(circle);
		}
		
		function hideUnitArea(circle){
			scene.remove(circle);
			showArea = false;
			currSelectedObj = null;
		}
		
		function convert2dCoordsTo3d(evt){
			let target = renderer.domElement;
			let box = target.getBoundingClientRect();

			let x1 = evt.clientX - box.left;
			let y1 = evt.clientY - box.top;
			let posX = x1 * target.width  / target.clientWidth;
			let posY = y1 * target.height / target.clientHeight;

			let x = posX / parseInt(target.width) * 2 - 1;
			let y = posY / parseInt(target.height) * -2 + 1;
			let v = new THREE.Vector3(x, y, -450).unproject( camera ); // understand what unproject does, cause it gives a ridiculous z value
			v.z = -450;
			return v;
		}
		
	// https://threejs.org/docs/#api/en/textures/Texture
	// create a mesh, apply ocean shader on it 
		loadedModels.push(getModel('../assets/battleship-edit.glb', 'player', 'p1'));
		loadedModels.push(getModel('../assets/battleship-edit.glb', 'player', 'p1'));
		loadedModels.push(getModel('../assets/battleship2.glb', 'enemy', 'e1'));
		loadedModels.push(getModel('../assets/battleship2.glb', 'enemy', 'e1'));
		
		Promise.all(loadedModels).then((objects) => {
			objects.forEach((mesh) => {
				
				let randX;
				if(mesh.side === "enemy"){
					// put enemies on the left half of the map
					randX = Math.floor(Math.random() * (0 - (-30) + 1) + (-30));
					enemyUnits.push(mesh);
				}else{
					randX = Math.floor(Math.random() * (30 - 2 + 1) + 2);
					playerUnits.push(mesh);
				}
				
				let randY = Math.floor(Math.random() * (50 - (-50) + 1) + (-50));
				mesh.position.set(randX, randY, -450);
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				
				scene.add(mesh);
				
				let geometry = new THREE.CircleGeometry( 17, 32 ); //new THREE.CircleGeometry( boundingSphereRadius, 32 );
				let material;
				if(mesh.side === "player"){
					material = new THREE.MeshBasicMaterial({color: 0xffff00});
				}else if(mesh.side === "enemy"){
					material = new THREE.MeshBasicMaterial({ color: 0x0000ff } ); // default is 0xffffff, fyi. you want transparent
				}
				// make one circle for attack range, and one for movement range
				let circle = new THREE.Mesh( geometry, material );
				circle.name = "selectArea";
				// get radius via: circle.geometry.parameters.radius
			
				mesh.selectArea = circle;
				if(mesh.side === "enemy"){
					circle.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
					//scene.add(circle);
					circle.side = "enemyArea";
				}else{
					circle.side = "playerArea";
				}
				
				renderer.render(scene, camera);
			})
		});
		

		scene.background = new THREE.Color( 0xffffff );	
		scene.add(camera);
		renderer.setSize(WIDTH, HEIGHT);	
		container.appendChild(renderer.domElement);
		
		function raycast(){
			// update the picking ray with the camera and mouse position
			raycaster.setFromCamera( mouse, camera );
			// calculate objects intersecting the picking ray
			var intersects = raycaster.intersectObjects( scene.children );

			// check if multiple hits! i.e. if player unit's area and enemy area overlap
			// see if current unit's selectArea and an enemy's selectArea intersect
			// if so, can't move 
			let intersectCheck = {};
			intersects.forEach((obj) => {
				if(obj.object.name === "selectArea" && (obj.object.side === "enemyArea" || obj.object.side === "playerArea")){
					intersectCheck[obj.object.side] = 1;
				}
			});
			if(intersectCheck["enemyArea"] && intersectCheck["playerArea"]){
				console.log("can't move - this point is an intersection with an enemy. try attacking?");
				return false;
			}


			for(var i = 0; i < intersects.length; i++) {
				//console.log("hit!");
				if(intersects[i].object.side === "player"){
					//console.log("player hit");
					intersects[i].object.material.color.set( colors[i % colors.length] );
					return intersects[i].object;
				}else if(intersects[i].object.name === "selectArea"){
					console.log("clicked on selectarea");
					return intersects[i].object;
				}else if(intersects[i].object.side === "enemy" && currSelectedObj){
					// need to make sure target is within range also!!
					console.log("attacking enemy");
					return intersects[i].object;
				}
			}
			return false;
		}
		
		function inRange(v1, v2, limit){
			return (v1.x <= v2.x + limit && v1.x >= v2.x - limit && v1.y <= v2.y + limit && v1.y >= v2.y - limit);
		}
		
		let wakeParticleDist = 0.5;
		function move(object, targetPos, directionVec, setIntervalName){
			// stop movement if reach target		
			// remember that in 3d space, downward movement means increasing negative numbers (unlike in 2d where going down means increasing positive value)
			if(inRange(object.position, targetPos, 0.1)){
				clearInterval(setIntervalName);
				wakeParts.forEach((part) => {
					// clear out particles
					part.status = false;
					part.update();
				});
				wakeParts = [];
			}else{
				object.position.addScaledVector(directionVec, 0.2);
				wakeParts.push(new wakeAnimation(object.position.x, object.position.y, object, targetPos));
			}
		}
		
		function rotate(object, angle, targetVec, setIntervalName){
			let limit = 0.02;
			let angleBetween = getAngleBetween(object, targetVec);
			if(angleBetween >= -limit && angleBetween <= limit){
				console.log("finished rotating");
				clearInterval(setIntervalName);
			}else{
				object.rotateOnAxis(new THREE.Vector3(0,1,0), angle);
			}
		}
		
		function getAngleBetween(obj, vec){
			// https://github.com/mrdoob/three.js/issues/1606
			let matrix = new THREE.Matrix4();
			matrix.extractRotation( obj.matrix );
			let direction = new THREE.Vector3( 0, 0, 1 );
			direction.applyMatrix4(matrix);

			let currDirectionVector = direction; 
			let angleBetween = currDirectionVector.angleTo(vec);
			return angleBetween;
		}
		
		function getVectorAtAngleFrom(baseVec, angleTo){
			let radians = THREE.Math.degToRad(angleTo);
			let matrix = new THREE.Matrix3().set(
				Math.cos(radians), -Math.sin(radians), 0,
				Math.sin(radians), Math.cos(radians), 0,
				0, 0, 1
			);
			let newVec = new THREE.Vector3(baseVec.x, baseVec.y, baseVec.z);
			newVec.applyMatrix3(matrix);
			return newVec;
		}
						
		renderer.domElement.addEventListener('click', (e) => {
			let v = convert2dCoordsTo3d(e);
			
			mouse.x = (( e.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width) * 2 - 1;
			mouse.y = - (( e.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height) * 2 + 1;

			let res = raycast();
			if(res){
				if(showArea && res.side === "player"){
					console.log("hide select area");
					hideUnitArea(res.selectArea);
				}else if(showArea && currSelectedObj && res.name === "selectArea" && res.side !== "enemyArea"){
					console.log("moving");
					// move unit?
					let obj = currSelectedObj;
					obj.isMoving = true;
					// point unit in direction and move if possible
					// step 1: get 3d point clicked on 
					// step 2: get vector using point clicked on and unit's curr coords 
					// step 3: given curr unit's curr direction vector, find angle between 
					//			vector and the vector obtained in step 2.
					// step 4: rotate curr unit vector x degrees from step 3.
					let vec = new THREE.Vector3(v.x - obj.position.x, v.y - obj.position.y, v.z - obj.position.z);
					
					// get curr unit direction vector 
					// https://github.com/mrdoob/three.js/issues/1606
					let angleBetween = getAngleBetween(obj, vec);
					
					// figure out if the angle should be added (clockwise) or subtracted (rotate counterclckwise)
					// https://stackoverflow.com/questions/16613616/work-out-whether-to-turn-clockwise-or-anticlockwise-from-two-angles
					let matrix = new THREE.Matrix4();
					matrix.extractRotation(obj.matrix);
					let direction = new THREE.Vector3( 0, 0, 1 );
					direction.applyMatrix4(matrix);
					let currDirectionVector = direction; 
			
					let crossProductLength = currDirectionVector.cross(vec);
					if(crossProductLength.z > 0){
						// clockwise
						let rotateFunc = setInterval(
							function(){
								rotate(obj, angleBetween / 40, vec, rotateFunc);
							}, 35
						);
					}else{
						// counterclockwise
						let rotateFunc = setInterval(
							function(){
								rotate(obj, -angleBetween / 40, vec, rotateFunc);
							}, 35
						);
					}
					
					// move to point clicked
					vec.normalize();
					let moveFunc = setInterval(
							function(){
								move(obj, v, vec, moveFunc);
								obj.isMoving = false;
							}, 30
						);
					
					hideUnitArea(res);
					showArea = false;
				}else if(res.side === "player"){
					currSelectedObj = res;
					showUnitArea(res, res.selectArea);
					showArea = true;
				}else if(res.side === "enemy"){
					// hide player area 
					// deselect curr unit 
					hideUnitArea(currSelectedObj.selectArea);
					//currSelectedObj = null;
					attackUnit(res);
				}
			}
		});
		
		
		function render() {
			requestAnimationFrame( render );
			
			// for explosion particles
			var pCount = parts.length;
			while(pCount--) {
				parts[pCount].update();
			 }
			
			if(waterMaterial){
				waterMaterial.uniforms.time.value += 1.0 / 180.0;
			}
			
			// wake animation if unit moving 
			var wCount = wakeParts.length;
			while(wCount--){
				wakeParts[wCount].update();
			}
			
			renderer.render(scene, camera);
		}
		render();
		


	
	var noiseTexture = new THREE.TextureLoader().load( 'waternormals.jpg', function(texture){
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
	});
	
	var waterTexture = new THREE.TextureLoader().load( 'water.jpg', function(texture){
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
	});
		
	var waterGeometry = new THREE.PlaneBufferGeometry(1000, 1000);
	
	// what does type mean?
	var uniforms = {
		baseTexture: 	{ type: "t", value: waterTexture },
		baseSpeed: 		{ type: "f", value: 0.02 },
		noiseTexture: 	{ type: "t", value: noiseTexture },
		noiseScale:		{ type: "f", value: 0.2 },
		alpha: 			{ type: "f", value: 0.9 },
		time: 			{ type: "f", value: 0.0 }
	};
	
	var waterMaterial = new THREE.ShaderMaterial({
		uniforms: uniforms,
		vertexShader: waterShader['vertexShader'],
		fragmentShader: waterShader['fragmentShader']
	});
	waterMaterial.side = THREE.FrontSide;
	waterMaterial.transparent = true;
	
	var water = new THREE.Mesh(waterGeometry, waterMaterial);
	water.receiveShadow = true;
	water.position.x = 0;
	water.position.y = 0;
	water.position.z = -460;

	scene.add(water);
		
		

	let rotation = 0;
	window.addEventListener('keydown', event => {
		if(event.keyCode === 87){
			//camera.position.x -= 50;
			//rotation += 0.05;
			//camera.position.y = Math.sin(rotation) * 500;
			//camera.position.z = Math.cos(rotation) * 500;
			//camera.rotation.y = camera.rotation.y += .05;
		}
	});
	

	</script>

</html>