<html>

	<head>
		<title>sndfjklnsfkld</title>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js'></script>
		<script src='node_modules\three\examples\js\loaders\GLTFLoader.js'></script>
	</head>
	
	<style>
		#container{
			border: 1px solid #000;
		}
	</style>
	
	<body>
		<div id='container'>
		</div>
	</body>

	<script>
	
		let loader = new THREE.GLTFLoader();
	
		function getModel(modelFilePath, side){
			return new Promise((resolve, reject) => {
				loader.load(
					modelFilePath,
					function(gltf){
						gltf.scene.traverse((child) => {
							if(child.type === "Mesh"){
				
								let material = child.material;
								let geometry = child.geometry;
								let obj = new THREE.Mesh(geometry, material);
								
								obj.scale.x = child.scale.x * 20;
								obj.scale.y = child.scale.y * 20;
								obj.scale.z = child.scale.z * 20;
								obj.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI / 2); // note this on object's local axis! so when you rotate, the axes change (i.e. x becomes z)
								obj.rotateOnAxis(new THREE.Vector3(0,0,1), Math.PI / 2);
							
								obj.side = side; // player or enemy mesh?
								resolve(obj);
							}
						});
					},
					// called while loading is progressing
					function(xhr){
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// called when loading has errors
					function(error){
						console.log( 'An error happened' );
						console.log(error);
					}
				);
			});
		}
		
		let geometry = new THREE.CircleGeometry( 15, 32 );
		let material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
		let circle = new THREE.Mesh( geometry, material );
		
		function showUnitArea(circle){
			circle.position.set(obj.position.x, obj.position.y, -450);
			scene.add( circle );
		}
		
		function hideUnitArea(circle){
			scene.remove(circle);
		}
		
		function convert2dCoordsTo3d(evt){
			let target = renderer.domElement;
			let box = target.getBoundingClientRect();

			// this assumes elementClicked is a grid cell, whose parent is a row element, whose parent is the grid container (which is what we want)
			let x1 = evt.clientX - box.left;
			let y1 = evt.clientY - box.top;
			let posX = x1 * target.width  / target.clientWidth;
			let posY = y1 * target.height / target.clientHeight;

			let x = posX / parseInt(target.width) * 2 - 1;
			let y = posY / parseInt(target.height) * -2 + 1;
			let v = new THREE.Vector3(x, y, -450).unproject( camera ); // understand what unproject does, cause it gives a ridiculous z value
			v.z = -450;
			return v;
		}
		
		const WIDTH = 1400;
		const HEIGHT = 600;
		const VIEW_ANGLE = 100;
		const ASPECT = WIDTH / HEIGHT;
		const NEAR = 1;
		const FAR = 1000;
		const LEFT = WIDTH / -10;
		const RIGHT = WIDTH / 10;
		const TOP = HEIGHT / 10;
		const BOTTOM = HEIGHT / -10;
		
		const container = document.querySelector('#container');
		const renderer = new THREE.WebGLRenderer();
		const camera = new THREE.OrthographicCamera(LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);	
		const scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xffffff );
		
		scene.add(camera);
		renderer.setSize(WIDTH, HEIGHT);	
		container.appendChild(renderer.domElement);
		
		let showArea = false;
		renderer.domElement.addEventListener('click', (e) => {
			let v = convert2dCoordsTo3d(e);
			//console.log(v);
			//obj.position.x = v.x;
			//obj.position.y = v.y;
			//obj.position.z = v.z;
			
			if(showArea){
				hideUnitArea(circle);
				showArea = false;
				
				// point unit in direction and move if possible
				// step 1: get 3d point clicked on 
				// step 2: get vector using point clicked on and unit's curr coords 
				// step 3: given curr unit's curr direction vector, find angle between 
				//			vector and the vector obtained in step 2.
				// step 4: rotate curr unit vector x degrees from step 3.
				let vec = new THREE.Vector3(v.x - obj.position.x, v.y - obj.position.y, v.z-obj.position.z);
				vec = vec.normalize();
				
				let currUnitVector = new THREE.Vector3(1, 0, 0); // hardcode for now 
				let angleBetween = currUnitVector.angleTo(vec);
			
				console.log(angleBetween);
				obj.rotateOnAxis(new THREE.Vector3(0,1,0), angleBetween);
			}else{
				showUnitArea(circle);
				showArea = true;
			}
			
			renderer.render(scene, camera);
		});
		
		let spotLight = new THREE.SpotLight( 0xffffff );
		spotLight.position.set( 0, 0, 1 );
		spotLight.castShadow = true;
		spotLight.shadow.mapSize.width = 3000;
		spotLight.shadow.mapSize.height = 500;
		spotLight.shadow.camera.near = 10;
		spotLight.shadow.camera.far = 1000;
		spotLight.shadow.camera.fov = 30;
		scene.add(spotLight);
		
		let obj = null;
		let area = null;
		let loadedModels = [];
		loadedModels.push(getModel('../assets/battleship-edit.glb', 'player'));
		
		Promise.all(loadedModels).then((objects) => {
			objects.forEach((mesh) => {
				obj = mesh;
				mesh.position.set(0, 0, -450);
				scene.add(mesh);
				
				//var geometry = new THREE.CircleGeometry( 15, 32 );
				//var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
				//var circle = new THREE.Mesh( geometry, material );
				//circle.position.set(0, 0, -450);
				//scene.add( circle );

				renderer.render(scene, camera);
			})
		});
		


	</script>

</html>