<html>

	<head>
		<title>sndfjklnsfkld</title>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js'></script>
		<script src='node_modules\three\examples\js\loaders\GLTFLoader.js'></script>
	</head>
	
	<style>
		#container{
			border: 1px solid #000;
		}
	</style>
	
	<body>
		<div id='container'>
		</div>
	</body>

	<script>
	
		let loader = new THREE.GLTFLoader();
		let obj = null;
		let area = null;
		let boundingSphereRadius = null;
		let playerUnits = {};
		
		// THREE.CircleGeometry( 15, 32 )
		let geometry = null; //new THREE.CircleGeometry( boundingSphereRadius, 32 );
		let material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
		let circle = null;
		
		let raycaster = new THREE.Raycaster();
		let mouse = new THREE.Vector2(-1, -1);
	
		function getModel(modelFilePath, side){
			return new Promise((resolve, reject) => {
				loader.load(
					modelFilePath,
					function(gltf){
						gltf.scene.traverse((child) => {
							if(child.type === "Mesh"){
				
								let material = child.material;
								let geometry = child.geometry;
								let obj = new THREE.Mesh(geometry, material);
								
								obj.scale.x = child.scale.x * 20;
								obj.scale.y = child.scale.y * 20;
								obj.scale.z = child.scale.z * 20;
								obj.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI / 2); // note this on object's local axis! so when you rotate, the axes change (i.e. x becomes z)
								obj.rotateOnAxis(new THREE.Vector3(0,0,1), Math.PI / 2);
							
								obj.side = side; // player or enemy mesh?
								resolve(obj);
							}
						});
					},
					// called while loading is progressing
					function(xhr){
						console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// called when loading has errors
					function(error){
						console.log( 'An error happened' );
						console.log(error);
					}
				);
			});
		}
		
		function showUnitArea(circle){
			circle.position.set(obj.position.x, obj.position.y, -450);
			scene.add( circle );
		}
		
		function hideUnitArea(circle){
			scene.remove(circle);
		}
		
		function convert2dCoordsTo3d(evt){
			let target = renderer.domElement;
			let box = target.getBoundingClientRect();

			let x1 = evt.clientX - box.left;
			let y1 = evt.clientY - box.top;
			let posX = x1 * target.width  / target.clientWidth;
			let posY = y1 * target.height / target.clientHeight;

			let x = posX / parseInt(target.width) * 2 - 1;
			let y = posY / parseInt(target.height) * -2 + 1;
			let v = new THREE.Vector3(x, y, -450).unproject( camera ); // understand what unproject does, cause it gives a ridiculous z value
			v.z = -450;
			return v;
		}
		
		
		const WIDTH = 1400;
		const HEIGHT = 600;
		const VIEW_ANGLE = 100;
		const ASPECT = WIDTH / HEIGHT;
		const NEAR = 1;
		const FAR = 1000;
		const LEFT = WIDTH / -10;
		const RIGHT = WIDTH / 10;
		const TOP = HEIGHT / 10;
		const BOTTOM = HEIGHT / -10;
		
		const container = document.querySelector('#container');
		const renderer = new THREE.WebGLRenderer();
		const camera = new THREE.OrthographicCamera(LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);	
		const scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xffffff );
		
		scene.add(camera);
		renderer.setSize(WIDTH, HEIGHT);	
		container.appendChild(renderer.domElement);
		
		function onMouseEvent( event ) {
			// calculate mouse position in normalized device coordinates
			// (-1 to +1) for both components
			event.preventDefault();
			mouse.x = ( ( event.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width ) * 2 - 1;
			mouse.y = - ( ( event.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height ) * 2 + 1;
			//console.log(mouse.x);
			//console.log(mouse.y);
			render();
		}
		
		function raycast(){
			// update the picking ray with the camera and mouse position
			raycaster.setFromCamera( mouse, camera );
			// calculate objects intersecting the picking ray
			var intersects = raycaster.intersectObjects( scene.children );

			let colors = [0xff0000, 0x00ff00, 0x0000ff];
			//console.log(intersects);
			for ( var i = 0; i < intersects.length; i++ ) {
				//console.log("hit!");
				if(intersects[i].object.name === "player"){
					//console.log("player hit");
					intersects[ i ].object.material.color.set( colors[i % colors.length] );
					return intersects[i].object;
				}else if(intersects[i].object.name === "selectArea"){
					return intersects[i].object;
				}
			}
			return false;
		}
		
		let showArea = false;
		renderer.domElement.addEventListener('click', (e) => {
			let v = convert2dCoordsTo3d(e);
			console.log(v);
			
			mouse.x = ( ( e.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width ) * 2 - 1;
			mouse.y = - ( ( e.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height ) * 2 + 1;
			
			let res = raycast();
			//console.log(res);
			if(res){
				if(showArea && res.name === "player"){
					hideUnitArea(circle);
					showArea = false;
				}else if(showArea && res.name === "selectArea"){
					// move unit?
					
					// point unit in direction and move if possible
					// step 1: get 3d point clicked on 
					// step 2: get vector using point clicked on and unit's curr coords 
					// step 3: given curr unit's curr direction vector, find angle between 
					//			vector and the vector obtained in step 2.
					// step 4: rotate curr unit vector x degrees from step 3.
					let vec = new THREE.Vector3(v.x - obj.position.x, v.y - obj.position.y, v.z - obj.position.z);
					
					// get curr unit direction vector 
					// https://github.com/mrdoob/three.js/issues/1606
					let matrix = new THREE.Matrix4();
					matrix.extractRotation( obj.matrix );

					let direction = new THREE.Vector3( 0, 0, 1 );
					direction.applyMatrix4(matrix);

					//console.log(direction);
					let currUnitVector = direction; 
					let angleBetween = currUnitVector.angleTo(vec);
					
					//console.log(THREE.Math.radToDeg(angleBetween));
					// figure out if the angle should be added (clockwise) or subtracted (rotate counterclckwise)
					// https://stackoverflow.com/questions/16613616/work-out-whether-to-turn-clockwise-or-anticlockwise-from-two-angles
					let crossproductLength = currUnitVector.cross(vec);
					//console.log(crossproductLength.z);
					if(crossproductLength.z > 0){
						obj.rotateOnAxis(new THREE.Vector3(0,1,0), angleBetween);
					}else{
						obj.rotateOnAxis(new THREE.Vector3(0,1,0), -angleBetween);
					}
				}else{
					showUnitArea(circle);
					showArea = true;
				}
			}
			
			renderer.render(scene, camera);
		});
		
		let spotLight = new THREE.SpotLight( 0xffffff );
		spotLight.position.set( 0, 0, 1 );
		spotLight.castShadow = true;
		spotLight.shadow.mapSize.width = 3000;
		spotLight.shadow.mapSize.height = 500;
		spotLight.shadow.camera.near = 10;
		spotLight.shadow.camera.far = 1000;
		spotLight.shadow.camera.fov = 30;
		scene.add(spotLight);
		
		let loadedModels = [];
		loadedModels.push(getModel('../assets/battleship-edit.glb', 'player'));
		
		Promise.all(loadedModels).then((objects) => {
			objects.forEach((mesh) => {
				obj = mesh;
				mesh.position.set(0, 0, -450);
				mesh.name = "player"; // assign a name to the mesh 
				scene.add(mesh);
				mesh.geometry.computeBoundingSphere();
				boundingSphereRadius = mesh.geometry.boundingSphere.radius;
				//console.log(boundingSphereRadius);
				//var geometry = new THREE.CircleGeometry( 15, 32 );
				//var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
				//var circle = new THREE.Mesh( geometry, material );
				//circle.position.set(0, 0, -450);
				//scene.add( circle );
				
				geometry = new THREE.CircleGeometry( 15, 32 ); //new THREE.CircleGeometry( boundingSphereRadius, 32 );
				material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
				circle = new THREE.Mesh( geometry, material );
				circle.name = "selectArea";
				
				// try this instead https://threejs.org/docs/#api/en/core/Raycaster
				// for knowing what unit the mouse is over 
				//playerUnits["unit1"] = {'x': obj.position.x, 'y': obj.position.y}; // every time this unit moves it needs to be updated
				
				renderer.render(scene, camera);
				
				//window.addEventListener( 'mousemove', onMouseMove, false );
				//window.requestAnimationFrame(render);
			})
		});
		
		


	</script>

</html>