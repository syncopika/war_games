/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scripts_Game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scripts/Game.js */ \"./scripts/Game.js\");\n/* harmony import */ var _scripts_GameConsole_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/GameConsole.js */ \"./scripts/GameConsole.js\");\n/* harmony import */ var _scripts_enemyAI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/enemyAI.js */ \"./scripts/enemyAI.js\");\n/* harmony import */ var _scripts_cards_card1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/cards/card1.js */ \"./scripts/cards/card1.js\");\n/* harmony import */ var _scripts_cards_card2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts/cards/card2.js */ \"./scripts/cards/card2.js\");\n/* harmony import */ var _scripts_cards_card3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/cards/card3.js */ \"./scripts/cards/card3.js\");\n// https://stackoverflow.com/questions/41174095/do-i-need-to-use-onload-to-start-my-webpack-bundled-code\n\n\n\n\n\n\n/****   start game here  *****/\n\n$(function () {\n  /*****\r\n  \tinitiate first state of game \r\n  ******/\n  function initialState(length, height) {\n    // randomly place nyasu \n    // function placeRandom(element, health, attack, leftBound, rightBound, bottomBound, topBound, stats)\n    gameInstance.placeRandom(\"./assets/catadmiral.png\", length - 10, length, 0, height, {\n      'health': 100,\n      'attack': 20,\n      'className': 'player',\n      'unitType': 'boss'\n    }); // place enemies \n\n    for (var i = 0; i < 10; i++) {\n      gameInstance.placeRandom(\"./assets/gasmask.png\", 0, length, 0, height, {\n        'health': 20,\n        'attack': 5,\n        'className': 'enemy',\n        'unitType': 'infantry'\n      });\n    } // place enemy boss\n\n\n    gameInstance.placeRandom(\"./assets/enemyboss1.png\", 0, 10, 0, height, {\n      'health': 50,\n      'attack': 5,\n      'className': 'enemy',\n      'unitType': 'boss'\n    }); // place obstacles\n\n    for (var _i = 0; _i < 15; _i++) {\n      gameInstance.placeObstacles(0, length, 0, height);\n    }\n  } // set up map \n\n\n  var length = 36;\n  var height = 15;\n  var gameInstance = new _scripts_Game_js__WEBPACK_IMPORTED_MODULE_0__[\"Game\"]();\n  gameInstance.consoleElement = document.getElementById('console');\n  gameInstance.createGrid(length, height, document.getElementById('grid')); // set up units initially \n\n  initialState(length, height); // hook up end turn button with enemyTurn function \n\n  document.getElementById('endTurn').addEventListener('click', function () {\n    gameInstance.enemyTurn(_scripts_enemyAI_js__WEBPACK_IMPORTED_MODULE_2__[\"enemyMovement2\"]);\n  }); // load player's deck \n\n  var playerDeck = gameInstance.playerDeck;\n  playerDeck.add(_scripts_cards_card3_js__WEBPACK_IMPORTED_MODULE_5__[\"BearAttack\"]);\n  playerDeck.add(_scripts_cards_card1_js__WEBPACK_IMPORTED_MODULE_3__[\"CompleteDomination\"]);\n  playerDeck.add(_scripts_cards_card2_js__WEBPACK_IMPORTED_MODULE_4__[\"PancakeSniper\"]); // hook up end draw cards button with drawCards function \n\n  document.getElementById('drawCards').addEventListener('click', function () {\n    gameInstance.drawCards();\n  }); // add event listener to document to be able to click on enemy units and get some info \n  // what if selected enemy unit gets killed and their info was present? delete that info? \n  // if so, then maybe add an attribute for 'selectedEnemy' that wil equal the DOM element \n  // of the selected enemy. in the function where player attacks enemy, if enemy dies, check\n  // 'selectedEnemy' attribute if it was that enemy. \n\n  document.addEventListener('click', function (e) {\n    if (e.target.className === \"enemy\") {\n      var start = e.target.style.backgroundImage.indexOf(\"(\") + 2; // inclusive \n\n      var end = e.target.style.backgroundImage.indexOf(\")\") - 1; // not inclusive\n\n      var imgSrc = e.target.style.backgroundImage.substring(start, end);\n      document.getElementById('selectedEnemy').setAttribute('src', imgSrc);\n      document.getElementById('selectedEnemy').setAttribute('width', 90);\n      document.getElementById('selectedEnemy').setAttribute('height', 120);\n      document.getElementById('enemyHealth').textContent = e.target.getAttribute(\"health\");\n    }\n  });\n});\n/***************************/\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./scripts/Card.js":
/*!*************************!*\
  !*** ./scripts/Card.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Card = function Card(name, image, func, description) {\n  _classCallCheck(this, Card);\n\n  this.name = name;\n  this.image = image;\n  this.ability = func;\n  this.description = description;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Card); //export { Card };\n\n//# sourceURL=webpack:///./scripts/Card.js?");

/***/ }),

/***/ "./scripts/Deck.js":
/*!*************************!*\
  !*** ./scripts/Deck.js ***!
  \*************************/
/*! exports provided: Deck */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Deck\", function() { return Deck; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Deck =\n/*#__PURE__*/\nfunction () {\n  function Deck() {\n    _classCallCheck(this, Deck);\n\n    this.theDeck = [];\n  } // add card to deck \n\n\n  _createClass(Deck, [{\n    key: \"add\",\n    value: function add(card) {\n      this.theDeck.push(card);\n    } // get deck size \n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.theDeck.length;\n    } // get a card\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (this.theDeck.length === 0) {\n        return null;\n      } else {\n        return this.theDeck.pop();\n      }\n    }\n  }]);\n\n  return Deck;\n}();\n\n\n\n//# sourceURL=webpack:///./scripts/Deck.js?");

/***/ }),

/***/ "./scripts/Game.js":
/*!*************************!*\
  !*** ./scripts/Game.js ***!
  \*************************/
/*! exports provided: Game */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return Game; });\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ \"./scripts/Utils.js\");\n/* harmony import */ var _Deck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Deck.js */ \"./scripts/Deck.js\");\n/* harmony import */ var _Hand_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hand.js */ \"./scripts/Hand.js\");\n/* harmony import */ var _GameConsole_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameConsole.js */ \"./scripts/GameConsole.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar Game =\n/*#__PURE__*/\nfunction () {\n  function Game() {\n    _classCallCheck(this, Game);\n\n    this.playerUnits = [];\n    this.enemyUnits = [];\n    this.gameGridElement = null;\n    this.playerDeck = new _Deck_js__WEBPACK_IMPORTED_MODULE_1__[\"Deck\"]();\n    this.enemyDeck = new _Deck_js__WEBPACK_IMPORTED_MODULE_1__[\"Deck\"]();\n    this.handSize = 4; // how many cards a hand can have at a time \n\n    this.consoleDialog = [];\n    this.consoleElement = null; // assign the dom element that's supposed to hold the console \n\n    this.currentUnit = null;\n  }\n\n  _createClass(Game, [{\n    key: \"refreshConsole\",\n    value: function refreshConsole(msg) {\n      this.consoleDialog.push(msg);\n\n      if (this.consoleElement === null) {\n        var consoleEl = document.createElement('div');\n        document.body.appendChild(consoleEl);\n        this.consoleElement = consoleEl;\n      }\n\n      ReactDOM.render(React.createElement(_GameConsole_js__WEBPACK_IMPORTED_MODULE_3__[\"GameConsole\"], {\n        consoleDialog: this.consoleDialog\n      }), this.consoleElement);\n    }\n  }, {\n    key: \"clearEnemyUnits\",\n    value: function clearEnemyUnits() {\n      this.enemyUnits = [];\n    }\n  }, {\n    key: \"clearPlayerUnits\",\n    value: function clearPlayerUnits() {\n      this.playerUnits = [];\n    }\n  }, {\n    key: \"setHandSize\",\n    value: function setHandSize(newSize) {\n      this.handSize = newSize;\n    }\n  }, {\n    key: \"explosionAnimation\",\n    value: function explosionAnimation(timestamp, num, canvas) {\n      var _this = this;\n\n      if (num > 6) {\n        return;\n      }\n\n      var nextImage = new Image();\n      nextImage.src = './explosion_animation/' + num + '.png';\n\n      nextImage.onload = function () {\n        var ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.drawImage(nextImage, 0, 0, nextImage.width, nextImage.height);\n        window.requestAnimationFrame(function (timestamp) {\n          return _this.explosionAnimation(timestamp, num + 1, canvas);\n        });\n      };\n    }\n    /*****\r\n    \n    \tcreate the grid map \r\n    \tpass in the width as the number of cells wide the grid should be \r\n    \tpass in the height as in the number of rows the grid should have \r\n    \n    ******/\n\n  }, {\n    key: \"createGrid\",\n    value: function createGrid(width, height, parentElement) {\n      this.gameGridElement = parentElement;\n      this.refreshConsole(\"game started\");\n      var thisGameInstance = this;\n      var parent = parentElement; //console.log(\"width: \" + window.innerWidth + \" height: \" + window.innerHeight)\n\n      var w = Math.round(Math.floor(window.innerWidth / width) / 10) * 12; // calculate width of cell\n\n      var h = Math.round(Math.floor(window.innerHeight / height) / 10) * 8; // calculate height of cell\n      //console.log(\"w: \" + w + \" h: \" + h)\n\n      parent.style.padding = \"5px\";\n      var table = document.createElement('table');\n\n      for (var i = 0; i < height; i++) {\n        var newRow = document.createElement('tr');\n        newRow.style.width = \"100%\";\n        newRow.id = 'row' + i;\n        newRow.style.padding = \"0\";\n        newRow.style.margin = \"0\"; // if grid is 15 x 36, width per cell should be ~50, height ~40 \n\n        var _loop = function _loop(j) {\n          var newColumn = document.createElement('td');\n          newColumn.style.border = '1px solid #000';\n          newColumn.style.width = w + \"px\";\n          newColumn.style.height = h + \"px\";\n          newColumn.style.backgroundSize = \"100% 100%\";\n          newColumn.id = newRow.id + 'column' + j;\n          newColumn.setAttribute('pathLight', 0); // 0 == pathLight is off \n          // bind click event to highlight paths \n\n          newColumn.addEventListener('click', function () {\n            thisGameInstance.activeObject(newColumn, thisGameInstance.playerUnits);\n          }); //newColumn.addEventListener('click', function(){ thisGameInstance.activeObject(this, thisGameInstance.playerUnits); });   //note the difference from the arrow function!\n          // bind click event to move unit \n\n          newColumn.addEventListener('click', function () {\n            thisGameInstance.moveUnit(newColumn);\n          });\n          newRow.appendChild(newColumn);\n        };\n\n        for (var j = 0; j < width; j++) {\n          _loop(j);\n        }\n\n        table.appendChild(newRow);\n      }\n\n      parent.appendChild(table);\n    }\n    /*** \r\n    \tdraw a new hand (pull 3 cards) for the player \r\n    \t@gameInstance = instance of Game object \r\n    ***/\n\n  }, {\n    key: \"drawCards\",\n    value: function drawCards() {\n      var deck = this.playerDeck;\n\n      if (deck.length === 0) {\n        return;\n      } // shuffle deck first?\n\n\n      var max = this.handSize;\n\n      if (deck.length <= 2 && deck.length >= 1) {\n        max = deck.length;\n      } // if player already has some cards, the number of cards drawn can't exceed handSize!\n\n\n      var cardsDrawn = [];\n\n      for (var i = 1; i < max; i++) {\n        cardsDrawn.push(deck.remove());\n      } // to do later: don't hardcode the container\n\n\n      this.refreshConsole(\"player drew \" + cardsDrawn.length + \" cards!\");\n      ReactDOM.render(React.createElement(_Hand_js__WEBPACK_IMPORTED_MODULE_2__[\"CurrentHand\"], {\n        numCardsPerHand: max,\n        cards: cardsDrawn,\n        gameInstance: this\n      }), document.getElementById('showCards'));\n    }\n    /****\r\n    \tplace unit in random location\r\n    \tand add to either player's or enemy's list of units \r\n    \n    \tleftBound and rightBound are parameters to determine the range of where to place unit\r\n    \t\r\n    \t@element = path to the picture file for the unit\r\n    \t@leftBound = column to start at\r\n    \t@rightBound = column to end at \r\n    \t@topBound = top row boundary\r\n    \t@bottomBound = bottom row boundary\r\n    \t@stats = other information like className, id, health, attack, other html attributes in an associative array\r\n    \t\r\n    \tthe bound params are INCLUSIVE\r\n    ****/\n\n  }, {\n    key: \"placeRandom\",\n    value: function placeRandom(element, leftBound, rightBound, bottomBound, topBound, stats) {\n      var randomCol = Math.floor(Math.random() * (rightBound - leftBound - 1) + leftBound);\n      var randomRow = Math.floor(Math.random() * (topBound - bottomBound - 1) + bottomBound);\n      var randCell = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getCell\"])(randomRow, randomCol);\n\n      while (randCell.style.backgroundImage !== \"\") {\n        randomCol = Math.floor(Math.random() * (rightBound - leftBound - 1) + leftBound);\n        randomRow = Math.floor(Math.random() * (topBound - bottomBound - 1) + bottomBound);\n        randCell = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getCell\"])(randomRow, randomCol);\n      }\n\n      for (var property in stats) {\n        if (property === \"className\") {\n          randCell.className = stats[property];\n        } else {\n          randCell.setAttribute(property, stats[property]);\n        }\n      }\n\n      randCell.style.backgroundImage = \"url(\" + element + \")\"; // enemyUnits need to be pushed into the enemyUnits array\n\n      if (stats[\"className\"] === \"enemy\") {\n        this.enemyUnits.push(randCell);\n      } else if (stats[\"className\"] === \"player\") {\n        this.playerUnits.push(randCell);\n      }\n    }\n    /*****\r\n    \r\n    \tplace obstacles randomly\r\n    \r\n    ******/\n\n  }, {\n    key: \"placeObstacles\",\n    value: function placeObstacles(leftBound, rightBound, bottomBound, topBound) {\n      var randomCol = Math.floor(Math.random() * (rightBound - leftBound - 1) + leftBound);\n      var randomRow = Math.floor(Math.random() * (topBound - bottomBound - 1) + bottomBound);\n      var randCell = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getCell\"])(randomRow, randomCol);\n\n      while (randCell.style.backgroundImage !== \"\") {\n        randomCol = Math.floor(Math.random() * (rightBound - leftBound - 1) + leftBound);\n        randomRow = Math.floor(Math.random() * (topBound - bottomBound - 1) + bottomBound);\n        randCell = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getCell\"])(randomRow, randomCol);\n      }\n\n      randCell.style.backgroundColor = \"#000\";\n      randCell.className = \"obstacle\";\n    }\n    /*****\r\n    \r\n    \tenemy's turn \r\n    \t@enemyAI = a function that tells each enemy unit how to move \r\n    \r\n    ******/\n\n  }, {\n    key: \"enemyTurn\",\n    value: function enemyTurn(enemyAI) {\n      for (var i = 0; i < this.enemyUnits.length; i++) {\n        enemyAI(this.enemyUnits[i], this.enemyUnits, this.playerUnits);\n      }\n\n      alert('enemy ended turn');\n    }\n    /*****\r\n    \n    \tget attack range of unit \r\n    \t\r\n    *******/\n\n  }, {\n    key: \"getAttackRange\",\n    value: function getAttackRange(element, distance) {\n      // this element will return the top, bottom, left and right blocks\n      var paths = {}; // get the parent of this element. this element should be a column cell, so the parent will be the row\n\n      var row = parseInt(element.parentNode.id.match(/\\d+/g)[0]);\n      var column = parseInt(element.id.match(/\\d+/g)[1]); // check top coord \n\n      var topRow = document.getElementById(\"row\" + (row - distance));\n\n      if (topRow) {\n        topRow = topRow.childNodes;\n\n        for (var i = 0; i < topRow.length; i++) {\n          var col = parseInt(topRow[i].id.match(/\\d+/g)[1]);\n\n          if (col === column) {\n            // if a top cell exists for given distance \n            paths[\"top\"] = topRow[i];\n            break;\n          }\n        }\n      } else {\n        paths[\"top\"] = null;\n      } // check bottom coord \n\n\n      var bottomRow = document.getElementById(\"row\" + (row + distance));\n\n      if (bottomRow) {\n        bottomRow = bottomRow.childNodes;\n\n        for (var _i = 0; _i < bottomRow.length; _i++) {\n          var _col = parseInt(bottomRow[_i].id.match(/\\d+/g)[1]);\n\n          if (_col === column) {\n            // if a top cell exists for given distance \n            paths[\"bottom\"] = bottomRow[_i];\n            break;\n          }\n        }\n      } else {\n        paths[\"bottom\"] = null;\n      } // check left coord \n\n\n      paths[\"left\"] = null;\n      var currRow = element.parentNode.childNodes;\n\n      for (var _i2 = 0; _i2 < currRow.length; _i2++) {\n        var newCol = parseInt(currRow[_i2].id.match(/\\d+/g)[1]);\n\n        if (newCol === column - distance) {\n          paths[\"left\"] = currRow[_i2];\n          break;\n        }\n      } // check right coord \n\n\n      paths[\"right\"] = null;\n\n      for (var _i3 = 0; _i3 < currRow.length; _i3++) {\n        var _newCol = parseInt(currRow[_i3].id.match(/\\d+/g)[1]);\n\n        if (_newCol === column + distance) {\n          paths[\"right\"] = currRow[_i3];\n          break;\n        }\n      }\n\n      return paths;\n    } // make function accessible from the outside as well\n    //this.getAttackRange = getAttackRange;\n\n    /****\r\n    \r\n    \tshow paths when clicking on unit\r\n    \t\r\n    ****/\n\n  }, {\n    key: \"activeObject\",\n    value: function activeObject(currElement, playerList) {\n      // only the player can select/move their own units \n      if (!playerList.includes(currElement)) {\n        return;\n      } // update header in top of page to show current unit selected and current health\n      // this makes some assumptions of the id's of the relevant elements in the header \n\n\n      var imgUrl = currElement.style.backgroundImage; // need to eliminate the 'url()' part from the string \n\n      imgUrl = imgUrl.substring(imgUrl.indexOf('\"') + 1, imgUrl.indexOf(')') - 1); // note that this means the actual file path should not have quotes or parentheses!\n\n      document.getElementById('player').setAttribute('src', imgUrl);\n      document.getElementById('playerHealth').textContent = currElement.getAttribute(\"health\"); // what kind of unit is it?\n\n      if (currElement.style.backgroundImage !== \"\" && currElement.getAttribute('pathLight') == 0) {\n        // light up the paths \n        var elementPaths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getPathsDefault\"])(currElement);\n\n        for (var key in elementPaths) {\n          if (elementPaths[key]) {\n            elementPaths[key].style.border = \"1px solid #dddfff\";\n          }\n        }\n\n        currElement.setAttribute('pathLight', 1);\n        this.currentUnit = currElement; // if special unit, show attack paths \n\n        if (currElement.getAttribute(\"unitType\") === 'range2') {\n          var attackRange = this.getAttackRange(currElement, 2);\n\n          for (var path in attackRange) {\n            if (attackRange[path]) {\n              attackRange[path].style.border = \"1px solid #FF1919\";\n            }\n          }\n        }\n      } else if (currElement.style.backgroundImage !== \"\" && currElement.getAttribute('pathLight') == 1) {\n        // this is deselecting a unit \n        var _elementPaths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getPathsDefault\"])(currElement);\n\n        for (var _key in _elementPaths) {\n          if (_elementPaths[_key]) {\n            _elementPaths[_key].style.border = \"1px solid #000\"; //elementPaths[key].style.backgroundColor = \"transparent\";\n          }\n        } // if special unit, un-highlight attack paths also\n\n\n        if (currElement.getAttribute(\"unitType\") === 'range2') {\n          var _attackRange = this.getAttackRange(currElement, 2);\n\n          for (var _path in _attackRange) {\n            if (_attackRange[_path]) {\n              _attackRange[_path].style.border = \"1px solid #000\";\n            }\n          }\n        }\n\n        currElement.setAttribute('pathLight', 0);\n        this.currentUnit = null;\n      }\n    }\n    /*****\r\n    \n    \tmove player's units \r\n    \n    \t@element - the DOM element you want to move to \r\n    \t\r\n    ******/\n\n  }, {\n    key: \"moveUnit\",\n    value: function moveUnit(element) {\n      var _this2 = this;\n\n      if (this.currentUnit == null) {\n        return;\n      }\n\n      if (element.className === \"obstacle\") {\n        return;\n      } // if square is highlighted or red (#FF1919) (for ranged units like raichu)\n\n\n      if (element.style.border === '1px solid rgb(221, 223, 255)' || element.style.border === '1px solid rgb(255, 25, 25)') {\n        // red squares only indicate attack range, not movement, so don't allow movement there \n        if (element.style.backgroundImage === \"\" && element.style.border !== '1px solid rgb(255, 25, 25)') {\n          // for ranged units\n          // clear the red highlight\n          if (this.currentUnit.getAttribute(\"unitType\") === 'range2') {\n            // we can assume the current unit is a ranged attacker\n            // we can't assume what the range is, so the range ought to be another html attribute \n            var attackRange = this.getAttackRange(this.currentUnit, 2);\n\n            for (var path in attackRange) {\n              if (attackRange[path]) {\n                attackRange[path].style.border = \"1px solid #000\";\n              }\n            }\n          } // move the unit there \n\n\n          element.style.backgroundImage = this.currentUnit.style.backgroundImage;\n          element.setAttribute(\"health\", this.currentUnit.getAttribute(\"health\"));\n          element.setAttribute(\"attack\", this.currentUnit.getAttribute(\"attack\"));\n          element.setAttribute(\"unitType\", this.currentUnit.getAttribute(\"unitType\")); // clear old data for currentUnit\n\n          this.currentUnit.style.backgroundImage = \"\";\n          this.currentUnit.setAttribute(\"unitType\", null);\n          this.currentUnit.setAttribute(\"health\", null);\n          this.currentUnit.setAttribute(\"attack\", null);\n          var currUnitPaths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getPathsDefault\"])(this.currentUnit);\n\n          for (var key in currUnitPaths) {\n            if (currUnitPaths[key]) {\n              currUnitPaths[key].style.border = \"1px solid #000\";\n            }\n          } // update player array \n\n\n          for (var i = 0; i < this.playerUnits.length; i++) {\n            if (this.playerUnits[i] === this.currentUnit) {\n              this.playerUnits[i] = element;\n              break;\n            }\n          } // set currentUnit to new location\n\n\n          this.currentUnit = element;\n        } // if cell to move in is an enemy unit \n\n\n        if (element.className === \"enemy\") {\n          var animationCanvas = document.createElement('canvas'); // show animation \n\n          animationCanvas.width = parseInt(element.style.width);\n          animationCanvas.height = parseInt(element.style.height);\n          animationCanvas.style.zIndex = 1;\n          var canvasCtx = animationCanvas.getContext('2d');\n          canvasCtx.fillStyle = \"rgba(0,0,0,255)\";\n          canvasCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);\n          element.appendChild(animationCanvas);\n          window.requestAnimationFrame(function (timestamp) {\n            _this2.explosionAnimation(timestamp, 1, animationCanvas);\n          }); // do damage\n          // show some effects when dealing damage\n\n          var damage = element.getAttribute(\"health\") - this.currentUnit.getAttribute(\"attack\");\n\n          if (damage <= 0) {\n            // remove from enemyUnits array \n            this.enemyUnits.splice(this.enemyUnits.indexOf(element), 1); // obliterate enemy \n\n            var gridContainer = element.parentNode.parentNode.parentNode.id;\n\n            if (this.currentUnit.getAttribute(\"unitType\") === 'range2') {\n              $('#' + gridContainer).effect(\"bounce\");\n            } else {\n              $('#' + gridContainer).effect(\"shake\");\n            } // remove animation canvas \n\n\n            setTimeout(function () {\n              element.removeChild(animationCanvas);\n            }, 300);\n            element.classList.remove(\"enemy\");\n            element.style.backgroundImage = \"\";\n            element.setAttribute(\"health\", null);\n            element.setAttribute(\"attack\", null);\n            element.setAttribute(\"unitType\", null);\n          } else {\n            if (this.currentUnit.getAttribute(\"unitType\") === 'range2') {\n              $('#grid').effect(\"bounce\");\n            } else {\n              $('#grid').effect(\"shake\");\n            }\n\n            element.setAttribute(\"health\", damage);\n          }\n\n          var _currUnitPaths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getPathsDefault\"])(this.currentUnit);\n\n          for (var _key2 in _currUnitPaths) {\n            if (_currUnitPaths[_key2]) {\n              _currUnitPaths[_key2].style.border = \"1px solid #000\";\n            }\n          }\n\n          this.currentUnit.setAttribute('pathLight', 0); // for ranged units\n          // clear the red highlight\n\n          if (this.currentUnit.getAttribute(\"unitType\") === 'range2') {\n            // we can assume the current unit is a ranged attacker\n            // we can't assume what the range is, so the range ought to be another html attribute \n            var _attackRange2 = this.getAttackRange(this.currentUnit, 2); //console.log(attackRange);\n\n\n            for (var _path2 in _attackRange2) {\n              if (_attackRange2[_path2]) {\n                _attackRange2[_path2].style.border = \"1px solid #000\";\n              }\n            }\n          }\n\n          this.refreshConsole(\"player attacked!\");\n        } // end if enemy \n\n      }\n    }\n  }]);\n\n  return Game;\n}();\n\n\n\n//# sourceURL=webpack:///./scripts/Game.js?");

/***/ }),

/***/ "./scripts/GameConsole.js":
/*!********************************!*\
  !*** ./scripts/GameConsole.js ***!
  \********************************/
/*! exports provided: GameConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GameConsole\", function() { return GameConsole; });\n// the Game component will pass the console messages to display\nvar GameConsole = function GameConsole(props) {\n  //console.log(props);\n  var consoleStyle = {\n    'fontFamily': 'monospace',\n    'fontSize': '14px',\n    'overflowY': 'scroll',\n    'height': '200px',\n    'width': '700px',\n    'border': '1px solid #000',\n    'margin': '0 auto',\n    'paddingLeft': '5px'\n  };\n  return React.createElement('div', {\n    style: consoleStyle\n  }, props.consoleDialog.map(function (line, i) {\n    return React.createElement('p', {\n      key: i\n    }, \"\".concat(line));\n  }));\n};\n\n\n\n//# sourceURL=webpack:///./scripts/GameConsole.js?");

/***/ }),

/***/ "./scripts/Hand.js":
/*!*************************!*\
  !*** ./scripts/Hand.js ***!
  \*************************/
/*! exports provided: CardDisplay, CurrentHand */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CardDisplay\", function() { return CardDisplay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CurrentHand\", function() { return CurrentHand; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n// thought simply npm installing react and then importing from the node_modules directory would work\n// https://stackoverflow.com/questions/51765686/how-to-obtain-es6-module-of-react-and-reactdom\n// https://github.com/facebook/react/issues/11503\n// https://github.com/wearespindle/react-ecmascript\n// to be used as a child component of CurrentHand \nvar CardDisplay =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(CardDisplay, _React$Component);\n\n  function CardDisplay(props) {\n    var _this;\n\n    _classCallCheck(this, CardDisplay);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CardDisplay).call(this, props));\n    _this.state = {\n      'index': _this.props.index,\n      'name': _this.props.name,\n      'image': _this.props.image,\n      'description': _this.props.description,\n      'ability': _this.props.ability\n    };\n    return _this;\n  }\n\n  _createClass(CardDisplay, [{\n    key: \"render\",\n    value: function render() {\n      var titleStyle = {\n        'fontWeight': 'bold'\n      };\n      var imageStyle = {\n        'width': '200px',\n        'height': '150px',\n        'marginTop': '10px'\n      };\n      var buttonStyle = {\n        'marginTop': '10px'\n      };\n      return React.createElement(\"div\", {\n        \"class\": \"card\"\n      }, React.createElement(\"div\", {\n        style: titleStyle\n      }, this.state.name), React.createElement(\"div\", null, React.createElement(\"img\", {\n        src: this.state.image,\n        style: imageStyle\n      })), React.createElement(\"div\", null, this.state.description), React.createElement(\"button\", {\n        style: buttonStyle,\n        onClick: this.state.ability\n      }, \"activate\"));\n      /*\r\n      return React.createElement('div',\r\n      \t{className: \"card\"},\r\n      \tReact.createElement('div', {style: titleStyle}, this.state.name),\r\n      \tReact.createElement('img', {style: imageStyle, src: this.state.image}),\r\n      \tReact.createElement('div', null, this.state.description),\r\n      \tReact.createElement('button', {style: buttonStyle, onClick: () => {\r\n      \t\tthis.state.ability();\r\n      \t}}, 'activate')\r\n      )*/\n    }\n  }]);\n\n  return CardDisplay;\n}(React.Component);\n\nvar CurrentHand =\n/*#__PURE__*/\nfunction (_React$Component2) {\n  _inherits(CurrentHand, _React$Component2);\n\n  function CurrentHand(props) {\n    var _this2;\n\n    _classCallCheck(this, CurrentHand);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CurrentHand).call(this, props));\n    _this2.state = {\n      'numCardsPerHand': _this2.props.numCardsPerHand,\n      'cards': _this2.props.cards,\n      'cardStates': Array(_this2.props.numCardsPerHand).fill(true),\n      'gameInstance': _this2.props.gameInstance\n    };\n    return _this2;\n  } // on updating arrays in state: https://stackoverflow.com/questions/26253351/correct-modification-of-state-arrays-in-reactjs\n\n\n  _createClass(CurrentHand, [{\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var cardDisplays = this.state.cards.map(function (card, i) {\n        if (_this3.state.cardStates[i] === true) {\n          return React.createElement(CardDisplay, {\n            key: i,\n            // key is special so it can't be accessed from props (will just be 'undefined')\n            index: i,\n            name: card.name,\n            image: card.image,\n            description: card.description,\n            ability: function ability() {\n              card.ability(_this3.props.gameInstance, card.name); // make it so that after the ability is activated, this hand is immediately notified that the card has been used and should be \n              // eliminated from view \n\n              _this3.setState(function (state) {\n                var copy = _toConsumableArray(state.cardStates);\n\n                copy[i] = false;\n                return {\n                  'cardStates': copy\n                };\n              });\n            }\n          });\n        }\n      });\n      return React.createElement('div', null, cardDisplays);\n    }\n  }]);\n\n  return CurrentHand;\n}(React.Component);\n\n\n\n\n//# sourceURL=webpack:///./scripts/Hand.js?");

/***/ }),

/***/ "./scripts/Utils.js":
/*!**************************!*\
  !*** ./scripts/Utils.js ***!
  \**************************/
/*! exports provided: getPathsDefault, getCell, validSpace, leaveSpace, selectEnemyOn, selectEnemyOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPathsDefault\", function() { return getPathsDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCell\", function() { return getCell; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validSpace\", function() { return validSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"leaveSpace\", function() { return leaveSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectEnemyOn\", function() { return selectEnemyOn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectEnemyOut\", function() { return selectEnemyOut; });\n// utility functions that do general things\n// since functions in my enemy AI file and my Game file need to use these functions, they're here \n\n/*****\r\n\tdefault path option\r\n\tget the top, bottom, left, and right cells of clicked-on unit \r\n*******/\nfunction getPathsDefault(element) {\n  // this element will return the top, bottom, left and right blocks\n  var paths = {}; // get the parent of this element. this element should be a column cell, so the parent will be the row\n\n  var row = parseInt(element.parentNode.id.match(/\\d+/g)[0]);\n  var column = parseInt(element.id.match(/\\d+/g)[1]); // top coordinate is row - 1, same column num\n  // bottom coord is row + 1, same column num\n  // left coord is column num - 1, same row \n  // right coord is column num + 1, same row \n\n  if (element.parentNode.previousSibling) {\n    var previousRow = element.parentNode.previousSibling.childNodes;\n\n    for (var i = 0; i < previousRow.length; i++) {\n      if (previousRow[i].id.match(/\\d+/g)[1] == column) {\n        paths['top'] = previousRow[i];\n        break;\n      }\n    }\n  } else {\n    paths['top'] = null;\n  }\n\n  if (element.parentNode.nextSibling) {\n    var nextRow = element.parentNode.nextSibling.childNodes;\n\n    for (var _i = 0; _i < nextRow.length; _i++) {\n      if (nextRow[_i].id.match(/\\d+/g)[1] == column) {\n        paths['bottom'] = nextRow[_i];\n        break;\n      }\n    }\n  } else {\n    paths['bottom'] = null;\n  }\n\n  paths['left'] = element.previousSibling;\n  paths['right'] = element.nextSibling;\n  return paths;\n} // get the DOM element that represents a cell in the grid given a row and column. \n\n\nfunction getCell(row, col) {\n  // changing let to var here stopped Chrome from complaining. why?\n  var rowElement = document.getElementById('row' + row).childNodes;\n\n  for (var i = 0; i < rowElement.length; i++) {\n    if (rowElement[i].id === 'row' + row + 'column' + col) {\n      return rowElement[i];\n    }\n  }\n\n  return null;\n} // highlight valid cell to place unit within player's territory\n\n\nfunction validSpace(e) {\n  var findDigit = e.target.id.match(/\\d+/g);\n\n  if (findDigit !== null) {\n    var col = parseInt(findDigit[1]); // come up with a separate function to determine whether a square is within player territory\n\n    if (col > 32) {\n      // highlight spot because this is a valid place to place unit\n      e.target.style.border = \"1px solid rgb(221, 223, 255)\";\n    }\n  }\n} // when hovering over an enemy to select for an attack\n\n\nfunction selectEnemyOn(e) {\n  if (e.target.className === \"enemy\") {\n    e.target.style.border = \"1px solid rgb(221, 223, 255)\";\n  }\n} // when hovering over an enemy to select for an attack and the cursor leaves \n\n\nfunction selectEnemyOut(e) {\n  if (e.target.className === \"enemy\") {\n    e.target.style.border = \"1px solid #000\";\n  }\n} // when moving over grid cells, de-highlight cells passed over if cursor moves to another cell \n\n\nfunction leaveSpace(e) {\n  var findDigit = e.target.id.match(/\\d+/g);\n\n  if (findDigit !== null) {\n    var col = parseInt(e.target.id.match(/\\d+/g)[1]); // come up with a separate function to determine whether a square is within player territory\n\n    if (col > 32) {\n      e.target.style.border = \"1px solid #000\";\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack:///./scripts/Utils.js?");

/***/ }),

/***/ "./scripts/cards/card1.js":
/*!********************************!*\
  !*** ./scripts/cards/card1.js ***!
  \********************************/
/*! exports provided: CompleteDomination */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompleteDomination\", function() { return CompleteDomination; });\n/* harmony import */ var _Card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Card.js */ \"./scripts/Card.js\");\n// card name: completeDomination\n\nvar CompleteDomination = new _Card_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"complete domination\", \"./assets/mikudayo.png\", function (gameInstance, name) {\n  // wipe out all enemies \n  gameInstance.refreshConsole(\"Player invoked \" + name + \"!\");\n  var enemyUnits = gameInstance.enemyUnits;\n\n  for (var i = 0; i < enemyUnits.length; i++) {\n    $('#grid').effect(\"shake\");\n    enemyUnits[i].style.backgroundImage = \"\";\n    enemyUnits[i].classList.remove(\"enemy\");\n    enemyUnits[i].setAttribute('health', null);\n    enemyUnits[i].setAttribute('attack', null);\n  }\n\n  gameInstance.clearEnemyUnits();\n}, \"mikudayo wipes out all enemies. yay\");\n\n\n//# sourceURL=webpack:///./scripts/cards/card1.js?");

/***/ }),

/***/ "./scripts/cards/card2.js":
/*!********************************!*\
  !*** ./scripts/cards/card2.js ***!
  \********************************/
/*! exports provided: PancakeSniper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PancakeSniper\", function() { return PancakeSniper; });\n/* harmony import */ var _Card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Card.js */ \"./scripts/Card.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../Utils.js */ \"./scripts/Utils.js\");\n\n\nvar PancakeSniper = new _Card_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"pancake sniper\", \"./assets/pancakesniper2.png\", function (gameInstance, name) {\n  // place a pancake sniper on the field \n  // https://stackoverflow.com/questions/4402287/javascript-remove-event-listener\n  var currentUnit = gameInstance.currentUnit;\n  var player = gameInstance.playerUnits; // after picking this ability, the unit needs to be placed immediately\n  // therefore, if there was a unit selected right before clicking this ability,\n  // it needs to be unselected\n\n  if (currentUnit) {\n    var elementPaths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"getPathsDefault\"])(currentUnit);\n\n    for (var key in elementPaths) {\n      if (elementPaths[key]) {\n        //elementPaths[key].style.border = \"none\";\n        elementPaths[key].style.border = \"1px solid #000\";\n      }\n    }\n\n    currentUnit.setAttribute('pathLight', 0);\n    gameInstance.currentUnit = null;\n  } // need to disable clicking anything else other than a valid space after this card has been selected \n\n\n  document.getElementById('grid').addEventListener('mouseover', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"validSpace\"]);\n  document.getElementById('grid').addEventListener('mouseout', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"leaveSpace\"]);\n  document.getElementById('grid').addEventListener('click', function placeUnit(e) {\n    var col = parseInt(e.target.id.match(/\\d+/g)[1]);\n\n    if (col > 32 && e.target.style.backgroundImage === \"\") {\n      // place the unit \n      e.target.style.backgroundImage = \"url('\" + \"./assets//pancakesniper2.png\" + \"')\";\n      e.target.setAttribute(\"health\", 120);\n      e.target.setAttribute(\"attack\", 70);\n      e.target.setAttribute(\"unitType\", 'range2');\n      e.target.className = \"player\";\n      player.push(e.target); // add new unit to player's units array\n\n      currentUnit = e.target; // set as current unit \n\n      gameInstance.refreshConsole(\"Player placed \" + name + \"!\"); // remove highlighted border\n\n      e.target.style.border = \"1px solid #000\"; // remove the event listeners associated with this card\n\n      document.getElementById('grid').removeEventListener('mouseout', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"leaveSpace\"]);\n      document.getElementById('grid').removeEventListener('mouseover', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"validSpace\"]);\n      document.getElementById('grid').removeEventListener('click', placeUnit);\n    }\n  });\n}, \"a sniper that shoots hot and fresh pancakes. after clicking 'activate', select a cell from any of the first three columns from the right to place a new unit. red highlighted squares indicate its attack range\");\n\n\n//# sourceURL=webpack:///./scripts/cards/card2.js?");

/***/ }),

/***/ "./scripts/cards/card3.js":
/*!********************************!*\
  !*** ./scripts/cards/card3.js ***!
  \********************************/
/*! exports provided: BearAttack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BearAttack\", function() { return BearAttack; });\n/* harmony import */ var _Card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Card.js */ \"./scripts/Card.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../Utils.js */ \"./scripts/Utils.js\");\n\n\nvar BearAttack = new _Card_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"bear attack\", \"./assets/bearattack.png\", function (gameInstance, name) {\n  var currentUnit = gameInstance.currentUnit;\n  var enemies = gameInstance.enemyUnits; // MAKE SURE TO CLEAR THE CARD AFTER USING IT! CLEAR CHILD NODES FROM PARENT\n  //console.log(this);\n  // launch a bear attack on a specified enemy unit \n  // does 10 damage \n  // make sure to show damage done and which unit\n  // NEED TO DISABLE MOVEUNIT() EXECUTION WHEN DOING THIS!\n\n  gameInstance.refreshConsole(\"Player activated \" + name + \"!\"); // clear the currentUnit in case some unit is selected while trying to implement attack\n  // don't forget possible ranged attack \n\n  if (currentUnit) {\n    var paths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"getPathsDefault\"])(currentUnit);\n\n    for (var path in paths) {\n      if (paths[path]) {\n        paths[path].style.border = \"1px solid #000\";\n      }\n    }\n\n    var attackRange = gameInstance.getAttackRange(currentUnit, 2);\n\n    for (var _path in attackRange) {\n      if (attackRange[_path]) {\n        attackRange[_path].style.border = \"1px solid #000\";\n      }\n    } // change pathLight so it will highlight when clicked on again \n\n\n    currentUnit.setAttribute(\"pathLight\", 0);\n    gameInstance.currentUnit = null;\n  }\n\n  document.getElementById('grid').addEventListener('mouseover', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"selectEnemyOn\"]);\n  document.getElementById('grid').addEventListener('mouseout', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"selectEnemyOut\"]);\n  document.getElementById('grid').addEventListener('click', function attack(e) {\n    // note that this event can only happen once! it's a one-time event \n    if (e.target.className === \"enemy\") {\n      // apply damage \n      $('#grid').effect(\"shake\");\n      var newHealth = e.target.getAttribute(\"health\") - 10;\n\n      if (newHealth <= 0) {\n        enemies.splice(enemies.indexOf(e.target), 1);\n        e.target.style.backgroundImage = \"\";\n        e.target.setAttribute(\"health\", null);\n        e.target.setAttribute(\"attack\", null);\n        e.target.classList.remove(\"enemy\");\n      } else {\n        e.target.setAttribute(\"health\", newHealth);\n      }\n\n      e.target.style.border = \"1px solid #000\"; // remove the event listeners associated with this card\n\n      document.getElementById('grid').removeEventListener('mouseout', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"selectEnemyOut\"]);\n      document.getElementById('grid').removeEventListener('mouseover', _Utils_js__WEBPACK_IMPORTED_MODULE_1__[\"selectEnemyOn\"]);\n      document.getElementById('grid').removeEventListener('click', attack);\n    }\n  });\n}, \"launch a bear attack on your favorite enemy.  after clicking 'activate', select one enemy unit to inflict 10 damage.\");\n\n\n//# sourceURL=webpack:///./scripts/cards/card3.js?");

/***/ }),

/***/ "./scripts/enemyAI.js":
/*!****************************!*\
  !*** ./scripts/enemyAI.js ***!
  \****************************/
/*! exports provided: enemyMovement, enemyMovement2, dfs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enemyMovement\", function() { return enemyMovement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enemyMovement2\", function() { return enemyMovement2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dfs\", function() { return dfs; });\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ \"./scripts/Utils.js\");\n/*****\r\n\r\n\tenemy movement AI sample 1\r\n\t\r\n\t@enemyMovement = DOM element of an enemy unit \r\n\t@enemyUnits = list of enemy units \r\n\t@playerUnits = list of player's units\r\n\t\r\n\tthis function should be passed to Game.enemyTurn()\r\n\t\r\n******/\n // the most basic possible movement. if there's an empty space left, right, up or down, go to either one randomly. \n// if any of the player's units are adjacent, then they will be attacked. \n\nfunction enemyMovement(enemyElement, enemyUnits, playerUnits) {\n  var player = playerUnits; // get left, right, top, bottom cells \n\n  var paths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getPathsDefault\"])(enemyElement); // attack if one of those cells contains one of the player's units\n\n  var _loop = function _loop(path) {\n    if (paths[path] === null) {\n      return \"continue\";\n    }\n\n    if (player.includes(paths[path])) {\n      // do attack \n      var opponent = paths[path];\n      var opponentHealth = opponent.getAttribute('health');\n      var currAttack = enemyElement.getAttribute('attack');\n      var newOpponentHealth = opponentHealth - enemyElement.getAttribute('attack'); // what if kill opponent?\n\n      if (newOpponentHealth <= 0) {\n        // obliterate opponent from map\n        document.getElementById('playerHealth').textContent = \"0\";\n        opponent.style.backgroundImage = \"\";\n        opponent.removeAttribute('health');\n        opponent.removeAttribute('attack');\n        opponent.removeAttribute('unittype');\n        opponent.classList.remove('player'); // remove from player array\n\n        player.splice(player.indexOf(opponent), 1);\n      } else {\n        // otherwise decrement health \n        opponent.style.border = \"1px solid #FF1919\"; // red border to indicate damage\n\n        opponent.setAttribute('health', opponentHealth - enemyElement.getAttribute('attack')); // only show current health for boss nyasu for now \n\n        if (paths[path].style.backgroundImage.match(/(nyasu7)/g)) {\n          document.getElementById('playerHealth').textContent = \"\" + opponentHealth - enemyElement.getAttribute('attack');\n        } // do some animation to indicate attack \n\n\n        setTimeout(function () {\n          $('#grid').effect(\"shake\");\n        }, 200);\n        var enemyCell = paths[path]; // assign a letiable paths[path]. can't just change paths[path] border because then only the last one in the loop will be referenced\n\n        setTimeout(function () {\n          enemyCell.style.border = \"1px solid #000\";\n          console.log(paths[path]);\n        }, 1000);\n      }\n    }\n  };\n\n  for (var path in paths) {\n    var _ret = _loop(path);\n\n    if (_ret === \"continue\") continue;\n  } // if no enemy, randomly move in a direction \n\n\n  var direction = Math.floor(Math.random() * 12);\n  var newCell;\n\n  if (direction < 3) {\n    // move right\n    newCell = enemyElement.nextSibling;\n  } else if (direction >= 3 && direction <= 6) {\n    // move left \n    newCell = enemyElement.previousSibling;\n  } else if (direction > 6 && direction <= 9) {\n    // move up \n    newCell = paths['top'];\n  } else {\n    // move down \n    newCell = paths['bottom'];\n  }\n\n  if (newCell === null) {\n    return;\n  } // but what if there is a fellow enemy in an adjacent square?\n\n\n  if (enemyUnits.includes(newCell)) {\n    return;\n  }\n\n  if (newCell.className === \"obstacle\") {\n    return;\n  }\n\n  newCell.setAttribute('health', enemyElement.getAttribute('health'));\n  newCell.setAttribute('attack', enemyElement.getAttribute('attack'));\n  newCell.className = \"enemy\";\n  newCell.style.backgroundImage = enemyElement.style.backgroundImage; // refactor this! probably can use a set for enemyUnits instead - remove old element, add new one \n\n  for (var i = 0; i < enemyUnits.length; i++) {\n    if (enemyUnits[i] === enemyElement) {\n      enemyUnits[i] = newCell;\n      break;\n    }\n  }\n\n  enemyElement.classList.remove(\"enemy\");\n  enemyElement.style.backgroundImage = \"\";\n}\n\nfunction dfs(element, elementToFind, enemySet) {\n  if (element === elementToFind) {\n    return [];\n  }\n\n  if (elementToFind === undefined) {\n    return [];\n  } // I think we can optimize this slightly(?) by reducing the number of possible nodes to be considered.\n  // since we know the row and column of our current node as well as of the target node,\n  // we can form a box (with the current and target nodes being corners) \n  // that defines row and column boundaries. so before we add a new potential node to visit \n  // to the stack, we check if it's row and column falls within the row/col boundaries.\n  //\n  // however, you could introduce some interesting bugs here:\n  // what about the scenario when the current and target node are in the same column, but \n  // there's another enemy in the way? the min and max columns would be the same, which would \n  // inhibit any horizontal movement! (so there would never be a path between the 2 nodes, and we get an infinite loop)\n  //\n  // similarly, what if they're in the same row and there's an obstacle? \n  // to remedy these situations, ensure that there is some extra room to move around if\n  // columns or rows are the same between current and target nodes. \n  //\n  // and here's another scenario: what if a unit is blocked off in a corner? i.e. there's another \n  // enemy blocking the only possible path, and is surrounded by obstacles in the other directions\n  // in this case, make sure that the node to find is in fact in the map of nodes and their predecessors as a key.\n  // this ensures there is a path from the current to target. \n\n\n  var selfNums = element.id.match(/\\d+/g);\n  var selfRow = parseInt(selfNums[0]);\n  var selfCol = parseInt(selfNums[1]);\n  var targetNums = elementToFind.id.match(/\\d+/g);\n  var targetRow = parseInt(targetNums[0]);\n  var targetCol = parseInt(targetNums[1]);\n  var rowBoundaryMin = Math.min(targetRow, selfRow);\n  var rowBoundaryMax = Math.max(targetRow, selfRow);\n\n  if (rowBoundaryMin === rowBoundaryMax) {\n    rowBoundaryMin--;\n    rowBoundaryMax++;\n  }\n\n  var colBoundaryMin = Math.min(targetCol, selfCol);\n  var colBoundaryMax = Math.max(targetCol, selfCol);\n\n  if (colBoundaryMin === colBoundaryMax) {\n    colBoundaryMin--;\n    colBoundaryMax++;\n  }\n\n  var stack = [element];\n  var seen = new Set();\n  var map = {}; // record path to get to elementToFind \n\n  map[element.id] = null;\n\n  while (stack.length > 0) {\n    var curr = stack.pop();\n\n    if (curr === elementToFind) {\n      break;\n    }\n\n    seen.add(curr);\n    var paths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getPathsDefault\"])(curr);\n\n    for (var dir in paths) {\n      if (paths[dir] === null) {\n        continue;\n      }\n\n      if (paths[dir].className === \"obstacle\" || enemySet.has(paths[dir])) {\n        continue;\n      }\n\n      if (!seen.has(paths[dir])) {\n        var rowCol = paths[dir].id.match(/\\d+/g);\n        var row = parseInt(rowCol[0]);\n        var col = parseInt(rowCol[1]);\n\n        if (row >= rowBoundaryMin && row <= rowBoundaryMax && col <= colBoundaryMax && col >= colBoundaryMin) {\n          map[paths[dir].id] = curr.id; // curr is the node that led to paths[dir]\n\n          stack.push(paths[dir]);\n        }\n      }\n    }\n  } // quick question: if instead of id's we use DOM elements as keys and values, \n  // why does that cause an infinite loop? is there anything different in hashing a string compared to a DOM element? \n  //console.log(element.id);\n  //console.log(elementToFind.id);\n  //console.log(map);\n  // return path to elementToFind\n\n\n  if (!map[elementToFind.id]) {\n    return [];\n  }\n\n  var pathToFollow = [];\n  var node = elementToFind.id;\n\n  while (node !== null) {\n    //console.log(node);\n    pathToFollow.push(node);\n    node = map[node];\n  } // pop off the first node since that's the one we're on \n\n\n  pathToFollow.pop(); // list of ids!\n\n  pathToFollow.reverse();\n  return pathToFollow;\n} // another kind of enemy movement - not very fast or precise\n// https://www.redblobgames.com/pathfinding/grids/algorithms.html\n// https://stackoverflow.com/questions/12864004/tracing-and-returning-a-path-in-depth-first-search\n\n\nfunction enemyMovement2(enemyElement, enemyUnits, playerUnits) {\n  // if enemy is adjacent, attack \n  var paths = Object(_Utils_js__WEBPACK_IMPORTED_MODULE_0__[\"getPathsDefault\"])(enemyElement); // attack if one of those cells contains one of the player's units\n\n  for (var _path in paths) {\n    if (paths[_path] === null) {\n      continue;\n    }\n\n    if (playerUnits.includes(paths[_path])) {\n      // do attack \n      var opponent = paths[_path];\n      var opponentHealth = opponent.getAttribute('health');\n      var currAttack = enemyElement.getAttribute('attack');\n      var newOpponentHealth = opponentHealth - enemyElement.getAttribute('attack'); // what if kill opponent?\n\n      if (newOpponentHealth <= 0) {\n        // obliterate opponent from map\n        document.getElementById('playerHealth').textContent = \"0\";\n        opponent.style.backgroundImage = \"\";\n        opponent.removeAttribute('health');\n        opponent.removeAttribute('attack');\n        opponent.removeAttribute('unittype');\n        opponent.classList.remove('player'); // remove from player array\n\n        playerUnits.splice(playerUnits.indexOf(opponent), 1);\n      } else {\n        (function () {\n          // otherwise decrement health \n          opponent.style.border = \"1px solid #FF1919\"; // red border to indicate damage\n\n          opponent.setAttribute('health', opponentHealth - enemyElement.getAttribute('attack')); // only show current health for boss nyasu for now \n\n          if (paths[_path].style.backgroundImage.match(/(nyasu7)/g)) {\n            document.getElementById('playerHealth').textContent = \"\" + opponentHealth - enemyElement.getAttribute('attack');\n          } // do some animation to indicate attack \n\n\n          setTimeout(function () {\n            $('#grid').effect(\"shake\");\n          }, 200);\n          var enemyCell = opponent; // assign a letiable paths[path]. can't just change paths[path] border because then only the last one in the loop will be referenced\n\n          setTimeout(function () {\n            enemyCell.style.border = \"1px solid #000\";\n          }, 1000);\n        })();\n      }\n\n      return;\n    }\n  } // otherwise, find a path to the enemy \n  //let player = new Set(playerUnits);\n\n\n  var enemies = new Set(enemyUnits); // pick a random playerUnit to focus on \n\n  var randIndex = Math.floor(Math.random() * playerUnits.length);\n  var unitToFind = playerUnits[randIndex]; // calculate a path to that target \n\n  var path = dfs(enemyElement, unitToFind, enemies);\n\n  if (path.length === 0) {\n    // enemy can't move \n    return;\n  }\n  /*\r\n  // checking out paths generated...\r\n  path.forEach((p) => {\r\n  \tlet colors = ['blue','red','pink','yellow','green','orange'];\r\n  \tlet rand = Math.floor(Math.random() * colors.length);\r\n  \tdocument.getElementById(p).style.backgroundColor = colors[rand]; //'pink';\r\n  });)*/\n  // go to the first element from the path \n\n\n  var newCell = document.getElementById(path[0]);\n  newCell.setAttribute('health', enemyElement.getAttribute('health'));\n  newCell.setAttribute('attack', enemyElement.getAttribute('attack'));\n  newCell.className = \"enemy\";\n  newCell.style.backgroundImage = enemyElement.style.backgroundImage;\n\n  for (var i = 0; i < enemyUnits.length; i++) {\n    if (enemyUnits[i] === enemyElement) {\n      enemyUnits[i] = newCell;\n      break;\n    }\n  }\n\n  enemyElement.classList.remove(\"enemy\");\n  enemyElement.style.backgroundImage = \"\";\n}\n\n\n\n//# sourceURL=webpack:///./scripts/enemyAI.js?");

/***/ })

/******/ });